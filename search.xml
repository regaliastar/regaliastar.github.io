<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript|面向对象</title>
      <link href="2020/12/23/js-oo/"/>
      <url>2020/12/23/js-oo/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是一门面向对象的语言，而面向对象有三大特性：封装、多态和继承。</p><p>在es5及以前，继承的特性是通过原型链实现的，这种方法繁琐又复杂，且有各自的问题。因此，es6新增了class关键词语法糖，虽然原理没变，依旧是利用原型链实现的类方法，却更简单直观了。</p><p><code>class</code> 其实是一种特殊的函数，同是JavaScript世界中的一等公民。</p><p>首先聊聊 <code>prototype、__proto__、constructor</code> 之间的关系，这也是实现面向对象的基础。</p><p><img src="/img/js-prototype.png" alt="出自https://blog.csdn.net/cc18868876837/article/details/81211729"></p><p>我们需要牢记两点： </p><ol><li><strong>proto</strong>和constructor属性是对象所独有的； </li><li>prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和constructor属性。 </li></ol><p><strong>proto</strong>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象（父对象）里找，一直找，直到<strong>proto</strong>属性的终点null，然后返回undefined，再往上找就相当于在null上取值，会报错。</p><p>通过<strong>proto</strong>属性将对象连接起来的这条链路即我们所谓的原型链。</p><p>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> === Foo.prototype。</p><p>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 </p><p>另外 <code>__proto__</code> 属性是浏览器对es5的实现，而不是es标准。</p><p>所有对象的prototype的<strong>proto</strong>都指向上一级的prototype，Function的上一级是Object，自定义函数的上一级也是Object。</p><p>每个函数都有一个prototype属性（函数独有），prototype属性里有两个属性，分别是：<code>constructor、__proto__</code>，其中，constructor就是本身，两者循环引用。每次调用该函数的构造方法创建一个实例的时候，这个实例内部的[[prototype]]指针就会被赋值为构造函数的prototype，在Firefox、Safari、Chrome的编译器中，这个<code>[[prototype]]</code>指针被实现为<code>__proto__</code>。</p><p>当对象遇到自己作用域内没有的属性或方法时，就会沿着原型链上找，如：<br>调用 <code>F.hasOwnProperty('name')</code> ，会调用 <code>F.prototype.__proto__.hasOwnProperty</code> 方法<br>默认情况下，所有引用类型都继承自<code>Object</code>，包括所有函数，因此F.prototype.<strong>proto</strong>就是Object.prototype。</p><p>在 <code>new</code> 操作符调用构造函数时会执行如下操作</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[Prototype]]特性被赋值为构造函数（就是指向该函数本身）的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结|常用算法</title>
      <link href="2020/12/16/leet-algo/"/>
      <url>2020/12/16/leet-algo/</url>
      
        <content type="html"><![CDATA[<p>总结一下经常出现 或 巧妙的算法~</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode 28 implement-strStr</a><br></p><pre class="line-numbers language-none"><code class="language-none">/** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle) {    function generateNext(needle){        let next = new Array(needle.length), x = 1, now = 0;        next[0] = 0        while(x &lt; needle.length){            if(needle[now] === needle[x]){                now += 1                next[x] = now                x++            }else{                if(now &gt; 0){                    now = next[now-1]                }else{                    next[x] = 0                    x++                }            }        }        return next    }    function core(haystack, needle){        if(needle == haystack){            return 0        }        const next = generateNext(needle)        let p1 = 0, p2 = 0;        while(p1 &lt; haystack.length &amp;&amp; p2 &lt; needle.length){            if(haystack[p1] === needle[p2]){                p1++                p2++            }else{                if(p2 &gt; 0){                    p2 = next[p2-1]                }else{                    p1++                }            }        }        if(p2 == needle.length){            return p1-p2        }        return -1     }    return core(haystack, needle)};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>奇淫巧技: 使用js内置方法<br><pre class="line-numbers language-none"><code class="language-none">var strStr = function(haystack, needle) {    return haystack.search(needle)};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个量子计算机</title>
      <link href="2020/12/14/qsim/"/>
      <url>2020/12/14/qsim/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近量子计算很火的样子，作为一个学计算机的，我们不妨自己做一个量子计算机<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>所谓的量子计算机，就是控制一系列量子比特的演化过程，对其施以酉变换，通过测量得出结果的装置。</p><p>在量子计算中，线路模型和图灵机模型理论上是等价的，最常用的量子计算模型便是线路模型，除此之外还有基于测量的模型，而前者比后者更直观简单，这也是我们选择用线路模型来实现的原因了。</p><p>下面我们用经典计算机来模拟量子计算的过程，实现一个量子计算模拟器（玩具版）。</p><h2 id="量子比特"><a href="#量子比特" class="headerlink" title="量子比特"></a>量子比特</h2><p>经典计算机使用比特进行计算，量子计算机就有量子比特，而单量子比特的矩阵表示有：</p><script type="math/tex; mode=display">\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix},\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}</script><p>对于多量子比特，则是单量子比特之间进行kronecker积：</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}1\\ 0\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 1\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\1\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\0\\1\\\end{pmatrix}</script><p>可以看到，对于2个比特的系统，向量的维度是4，而对于n个比特的系统，向量的维度就是$2^n$。可以做一个简单的估计，假设我们使用复数存储一个数字，计算它占据的大小<code>sys.getsizeof(c)</code>为32个字节，也就是说对于10比特的量子计算机，存储状态的空间就有32KB，对于20比特需要32MB，而30个量子比特就需要32GB，再往下就超出了个人计算机的极限了。</p><p>由于维度是指数级的增加，因此在经典计算机上只能进行有限的模拟，2018年一篇顶刊使用超级计算机（天河二号）模拟了超过50个量子比特，这已经是很大的进步了。当然，我们这里只是个玩具量子计算机 :)</p><p>首先引入需要的包：<br></p><pre class="line-numbers language-none"><code class="language-none">import numpy as npfrom sklearn.preprocessing import normalize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>现在生成初态的量子比特，1位比特维度是2，n位比特维度是$2^n$，使用kronecker积对比特维度进行计算。<p></p><p>定义 <code>basis</code> 方法得到kronecker积：<br></p><pre class="line-numbers language-none"><code class="language-none">def basis(string='00000'):    spin_up = np.array([[1, 0]]).T    spin_down = np.array([[0, 1]]).T    bit = [spin_up, spin_down]    res = np.array([[1]])    for idx in string[::-1]:        res = np.kron(bit[int(idx)], res)    return np.matrix(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>打开 <code>jupyter</code> 测试一下，生成4个量子比特 <code>0100</code> 的初态：<br><pre class="line-numbers language-none"><code class="language-none">amplitudes = basis('0100').A1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>打印 <code>amplitudes</code>:  <p></p><p><code>[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</code> </p><p><strong>如果想生成任意振幅的量子比特呢？</strong></p><p>在一个量子系统中，波函数可以写作：</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle} = \sum_{i=0}^{2^n-1}\alpha_i\mathinner{|i\rangle} \quad s.t. \sum_{i=0}^{2^n-1}\alpha_i^2 = 1</script><p>其中$\alpha_i$是振幅，$\mathinner{|i\rangle}$是基底，它们乘积之和就得到了一个叠加的波函数。</p><p>于是可以定义波函数 <code>wave_func</code><br></p><pre class="line-numbers language-none"><code class="language-none">def wave_func(coef=[], seqs=[]):    '''返回由振幅和几个Qubit序列表示的叠加态波函数'''    res = 0    for i, a in enumerate(coef):        res += a * basis(seqs[i])    return np.matrix(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>测试一下，生成量子叠加态 $\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}(\mathinner{|00\rangle}+\mathinner{|01\rangle}+\mathinner{|11\rangle})$:<br><pre class="line-numbers language-none"><code class="language-none">coef = [np.sqrt(1/3), np.sqrt(1/3), np.sqrt(1/3)]amplitudes = wave_func(coef=coef, seqs=['00','01','11']).A1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>打印 <code>amplitudes</code>: <p></p><p><code>[0.57735027 0.57735027 0.         0.57735027]</code> </p><p>注意到，这种表示方法非常的不友好，简直不是人读的！于是我们尝试对波函数在投影方向进行分解。</p><p>这里我们有投影算符：</p><script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}=P_\alpha\mathinner{|\gamma\rangle}=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p><p>先进行前置的准备工作：Hilbert空间是一个内积空间，所有量子比特都在Hilbert空间内。</p><p>定义生成 <code>Hilbert空间</code> 函数：</p><pre class="line-numbers language-none"><code class="language-none">def hilbert_space(nbit=5):    nspace = 2 ** nbit    for i in range(nspace):        # bin(7) = 0b100        binary = bin(i)[2:]        nzeros = nbit - len(binary)        yield '0' * nzeros + binary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再沿投影方向分解，投影的方向就是基向量的方向：<br></p><pre class="line-numbers language-none"><code class="language-none">def project(wave_func, direction):    '''&lt;Psi | phi_i&gt; to get the amplitude'''    return wave_func.H * directiondef decompose(wave_func):    '''将叠加态波函数分解'''    nbit = int(np.log2(len(wave_func)))    amplitudes = []    direct_str = []    for seq in hilbert_space(nbit):        direct = basis(seq)        amp = project(wave_func, direct).A1[0]  #A1 属性将矩阵转化为 1 维 numpy 数组        if np.linalg.norm(amp) != 0:            amplitudes.append(amp)            direct_str.append(seq)    return amplitudes, direct_str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>定义函数<code>a2wf</code>将 振幅 转为能被 <code>print_wf</code> 函数解析的 <code>wave_func</code> 格式<br><pre class="line-numbers language-none"><code class="language-none">def a2wf(amplitudes, n):    return np.mat(amplitudes.reshape(2 ** n, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>再使用 <code>print_wf</code> 函数打印出波函数<br><pre class="line-numbers language-none"><code class="language-none">def print_wf(wf):    coef, seqs = decompose(wf)    str = '|psi&gt; = '    for i, seq in enumerate(seqs):        str += '{}|{}&gt;'.format(coef[i], seq)        if i != len(seqs) - 1:            str += '+'    return str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>测试一下，生成一个大名鼎鼎的 <code>bell</code> 纠缠态 $\mathinner{|\varphi\rangle} = \frac{1}{\sqrt{2}}\mathinner{|00\rangle} + \frac{1}{\sqrt{2}}\mathinner{|11\rangle}$：<br></p><pre class="line-numbers language-none"><code class="language-none">wf = a2wf(np.matrix([np.sqrt(1/2),0,0,np.sqrt(1/2)]), 2)print_wf(wf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>打印：<br><code>|psi&gt; = 0.7071067811865476|00&gt;+0.7071067811865476|11&gt;</code></p><p>现在看起来就直观多了~</p><h2 id="量子门"><a href="#量子门" class="headerlink" title="量子门"></a>量子门</h2><p>量子计算机仅仅只有量子比特是不够的，为了实现量子算法，还需要对量子比特进行酉变换，这种变换我们使用量子门实现。</p><p>量子比特可以看做是布洛赫球上的一个向量：<br><img src="/img/qc-3-1.png" alt=""><br>量子门对应的就是该向量的旋转，要注意的一点是为了满足归一性，量子门必须是酉矩阵。</p><p>量子门分为单比特量子门和多比特量子门，对于单比特量子门，常用的有泡利矩阵：</p><script type="math/tex; mode=display">\sigma_x=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix}，\sigma_y=\begin{pmatrix}0 & -i\\ i & 0\\\end{pmatrix}，\sigma_z=\begin{pmatrix}1 & 0\\ 0 & -1\\\end{pmatrix}</script><p>代码实现：<br></p><pre class="line-numbers language-none"><code class="language-none">X = np.array([[0, 1], [1, 0]])Y = np.array([[0, -1j], [1j, 0]])Z = np.array([[1, 0], [0, -1]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Hadamard门：<br><pre class="line-numbers language-none"><code class="language-none">H = np.array([[1 / np.sqrt(2), 1 / np.sqrt(2)], [1 / np.sqrt(2), -1 / np.sqrt(2)]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>T门：<br><pre class="line-numbers language-none"><code class="language-none">T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>V门：<br><pre class="line-numbers language-none"><code class="language-none">V = np.array([[(1 + 1j) / 2, -1j * (1 + 1j) / 2], [-1j * (1 + 1j) / 2, (1 + 1j) / 2]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>我们将 <code>X</code> 门施加到一个基态为<code>0</code>的量子比特上：<br><pre class="line-numbers language-none"><code class="language-none">amplitudes = basis('0').A1wf = np.dot(amplitudes, X)print_wf(a2wf(wf, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>打印：<br><code>|psi&gt; = 1|1&gt;</code>  <p></p><p>完全符合预期。</p><p><strong>下面构造双量子门。</strong></p><p>已经被证明，所有多量子门都可以用双量子门和单量子门生成，因此我们只需要构造双量子门即可。</p><p>一般的双量子门有两种情况：</p><ol><li>控制位在上</li><li>控制位在下</li></ol><p>第一种情况很常见，如：</p><script type="math/tex; mode=display">CNOT=\begin{pmatrix}1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\0 & 0 & 1 & 0\\\end{pmatrix}</script><p>对于第二种情况，只需要将内部交换顺序，使用<code>CNOT_DOWN</code>表示控制位在下：</p><script type="math/tex; mode=display">CNOT\_DOWN=\begin{pmatrix}0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1\\\end{pmatrix}</script><p>同时，控制位和作用位不一定是紧挨着，它们之间可能存在<em>跨线</em>，这种情况稍微复杂一点。</p><p>还是拿<code>CNOT</code>门来举例，对于<strong>跨一条线且控制位在上</strong>的控制非门，我们定义为<code>CNOT3_02</code>，它的矩阵形式：</p><script type="math/tex; mode=display">CNOT3\_02=\begin{pmatrix}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\end{pmatrix}</script><p>可以看到，矩阵左上角是不变的，右下角重复<code>X</code>门</p><p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：<br></p><pre class="line-numbers language-none"><code class="language-none">base = np.identity(m_size)for i in range(int(m_size / 4)):    for j in range(2):        for k in range(2):            base[int(m_size / 2 + i * 2 + j)][int(m_size / 2 + i * 2 + k)] = GateManager.Gates[gate][j][k]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>对于<strong>跨一条线且控制位在下</strong>的控制非门，会更麻烦一点，<br>我们定义为<code>CNOT3_20</code>，它的矩阵形式：</p><script type="math/tex; mode=display">CNOT3\_20=\begin{pmatrix}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\end{pmatrix}</script><p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：<br></p><pre class="line-numbers language-none"><code class="language-none">base = np.identity(m_size)for i in range(int(m_size / 4)):    for j in range(2):        for k in range(2):            base[int(1 + 2 * i + j * m_size / 2)][int(1 + 2 * i + k * m_size / 2)] = GateManager.Gates[gate][j][k]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>一个量子系统是一个黑盒，在测试之前我们永远不知道它会塌缩到什么状态，而一个黑盒对我们来说是没有意义的。因此，从黑盒中提取出有用信息的过程就是测量了。</p><p>测量会将量子比特塌缩为经典比特，而该量子比特的振幅就是塌缩成0或1的概率。举个例子，对于一个量子状态</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=\begin{pmatrix}{}\frac{1}{\sqrt{3}}\\\frac{1}{\sqrt{3}}\\\frac{i}{\sqrt{3}}\\\end{pmatrix}</script><p>概率是以投影的形式给出的，而投影到<code>|0&gt;</code>状态的是算子为：</p><script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=\left(\begin{array}{c}1\\0\\0\\\end{array}\right)\left(\begin{array}{c}1 & 0 & 0\\\end{array}\right)</script><p>同时，</p><script type="math/tex; mode=display">\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=\begin{pmatrix}\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\\end{pmatrix}</script><p>因此我们可以计算出内积</p><script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p><p>已知了原理部分，就可以进行编码了。我们的量子计算机有两种测量方式，分别是进行全局测量和对单个比特进行测量，全局测量就是对所有比特同时进行测量：<br></p><pre class="line-numbers language-none"><code class="language-none">def measureAll():    probabilities = []    for amp in np.nditer(amplitudes):        probability = np.absolute(amp)**2        probabilities.append(probability)    results = list(range(len(probabilities)))    value = np.binary_repr(        np.random.choice(results, p=probabilities),        numQubits    )    return value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>我们也可以对单个比特进行测量：<br><pre class="line-numbers language-none"><code class="language-none">def measureOne(place):    prob_0 = 0    probabilities = np.zeros(2)    for i, seq in enumerate(seqs):        prob_0 += np.square(coef[i]) if seq[index] == '0' else 0    probabilities[0] = prob_0    probabilities[1] = 1 - prob_0    ls = [0, 1]    selected = np.random.choice(ls, p=probabilities)    measured[place] = 1    # 重新生成状态    co = []    ba = []    for i, seq in enumerate(seqs):        if seq[index] == str(selected):            co.append(coef[i])            ba.append(seq[0:index] + seq[index+1:len(seq)])    co = normalization(co)    amplitudes = wave_func(co, ba).A1    numQubits = len(ba[0])    return selected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>不同的是，在进行单个比特的测量后，需要重新生成状态。<p></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如此一来，我们就实现了一个量子计算机，麻雀虽小五脏俱全，绝大部分量子算法都可以用这个玩具实现了~</p><p>总结一下，我们用到了哪些知识：</p><ul><li>线性代数</li><li>量子力学基础</li><li>Python</li></ul><p>未来可以给这个量子计算机加上其他的功能，比如 <em>量子排列优化</em>、<em>量子线路分解</em>、<em>量子并行模拟</em> 等等，总之接下来就是搭积木了</p><blockquote><p>Reference<br>[1] <a href="https://github.com/adamisntdead/QuSimPy">https://github.com/adamisntdead/QuSimPy</a><br>[2] <a href="https://github.com/corbett/QuantumComputing">https://github.com/corbett/QuantumComputing</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/267302584">https://zhuanlan.zhihu.com/p/267302584</a><br>[4] <a href="https://qiskit.org/">qiskit文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 量子计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从奥术神座到数理学史</title>
      <link href="2020/11/13/phy-history/"/>
      <url>2020/11/13/phy-history/</url>
      
        <content type="html"><![CDATA[<p>说实话【奥术神座】这本书一直在我的书架上吃灰，直到看完诡秘之主，在强烈的书荒感下，我才捡起了乌贼娘的这本成神之作。</p><p>虽然是一本老书了，但是看了之后才意识到这果然是一本仙草，给我的惊喜感甚至超过了诡秘之主。就像是戳中了作为理科生的内心深处，我对这种“研究万物研究神”的小说没有丝毫抵抗力，幸好没有错过啊~</p><p>根据书中的设定，人的实力会随着认识世界的深刻程度而增强，换句话说就是“知识就是力量（物理版）”。</p><p>在一般的网络小说里，虽然力量等级的划分十分清晰，却很少会有作品去讨论“力量”的来源是什么。大家理所当然地拿来用，而几乎没有考虑过为什么会有魔法会有斗气。而奥术神座将神灵以及魔法纳入到物理体系中来，魔法就是科学，魔法是用来研究的对象，而创造魔法的过程就是人类研究大自然的过程。</p><p>曾经在知乎上看到过这么一个问题：“如果世界上真的有鬼，那么唯物主义者还会坚持他们的信仰吗？”</p><p>如果世界上真的有鬼，那么搞科研的才是最兴奋的吧——因为又可以在新的领域水paper了（笑）。只要是可观测的，那么鬼本身就是值得被研究的对象，说不定“鬼”本身会被称为一种特殊的“场”，同属物质世界的一部分。</p><p>在小说开头部分，路西恩的音乐家章节对应着文艺复兴的历史。从赞美神的宗教交响乐，再到以人为主题的流行乐，小说和现实交相辉映，让人读着不觉烦闷。不得不说，作者渲染气氛的功力实属老道，不管是对音乐会的描写，还是主人公拿出一个个经典乐曲的小高潮，从文字中都透出了音乐的美感。我想看了原文又去听音乐的应该不在少数，至少我是第一次把莫扎特的月光听完 :)</p><p>在书中后半部分，极为精彩的是其对数理学史的演绎。从波粒战争（异世界版）到量子力学的争议，书中的大奥术师基本都能在现实中找到原型。诸如：</p><p>道格拉斯——牛顿，爱因斯坦</p><p>费尔南多——泡利</p><p>奥利弗——薛定谔</p><p>布鲁克——麦克斯韦</p><p>迪耶普——德布罗意</p><p>列夫斯基——罗巴切夫斯基</p><p>他们争论的过程对应着物理学史的经典桥段，就像爱因斯坦对波尔怒吼：上帝不会掷骰子！</p><p>遗憾的是小说并没有涉及计算机科学的发展史，这也算是我的一点小私心了…</p><p>全文令我印象最深，也是让我为之颤抖的一段文字出自路西恩为了帮助列夫斯基（原型是罗巴切夫斯基，罗氏几何提出者）舌战群儒的片段，原文我贴在了附录中。非欧几何难以理解，但它却是广义相对论的数学基础，尽管当初提出它时人们并不知道它有什么作用。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p>以下出自小说原文</p></blockquote><p>路西恩整理了下领口，拿着一叠文件走上讲台，步伐稳健，不慌不忙。</p><p>“伊文斯委员，如果我是你，就不会再坚持，我很理解你对颠覆性成果的热爱，但这依然要尊重基本的现实。”涅西卡突然开口说道，如果路西恩的老师不是风暴主宰，他绝不会如此客气。</p><p>路西恩微笑看向他：“我只尊重真实。”</p><p>无论表情还是语气，委员们都能看出来他口中的真实是指列夫斯基的论文，于是米里娜轻轻笑了一声，却不带丝毫笑意，冰冷冷如同北地深处的寒风：“伊文斯委员，我想你不知道，如果一位审核委员在审核论文时犯下了明显的、故意的、没有理由的错误，他将被取消委员资格。”</p><p>“这句话也是我想对各位说的。”路西恩站到了讲台上，笑容平淡，话语却绝不柔和。</p><p>轰，仿佛有什么在内心炸响，一位位数理领域的委员都充满了愤怒，这是在指责和攻击我们？</p><p>费尔南多眨了眨眼睛，有点疑惑自己一向优雅有礼貌的学生竟然会说出这么带有挑衅意味的话语，他心里暗道，有点反常啊，看来有的人遇到麻烦了……</p><p>“伊文斯委员，你还是先想想怎么将想象中的几何变到现实中吧。”另外一位女性委员玛佩尔嘲讽道，她容貌平凡，古板严肃，带着灰顶尖帽，如同教会的老修女。</p><p>黑色头发凌乱，似乎不太喜欢打理自己的中年男士萨尔盖罗左手拇指和食指捏住脸庞，声音低沉地道：“我很想知道伊文斯委员你为什么将列夫斯基的论文称为几何领域的微积分革命，你有什么理由？你能证明他的正确吗？”</p><p>“你在数理领域没有什么成果，我严重怀疑你审核这篇论文的能力。”最先说话的涅西卡直接质疑起路西恩的数理水准。</p><p>被路西恩的话语激怒，一位位委员都变成了好斗的公鸡。</p><p>路西恩举手压了压，声音响亮：“对于我数理水准的质疑，请在我讲解完之后再向委员会提出。”</p><p>接着他略带咆哮地道：“从现在开始，论文以外的一切统统消失，你们是审核委员，不是小孩子！”</p><p>被这突如其来的咆哮震住，会议室一下变得安静。</p><p>路西恩环视会议室一圈，对列夫斯基微微点头，接着高声道：“我讲述理由时，不允许提问，不允许打断，所有的问题都等到讲述完一起提出，不过，我讲述时，会向各位提问，请各位诚实地回答，对得起胸口的委员徽章和头顶的星空！”</p><p>委员们沉默了，一时找不到反驳路西恩的理由，作为一名审核委员，作为三次霍尔姆皇冠奖、一次不朽王座奖得主，他有资格提出一定的合理要求，而且他的气势就像蓄势待发的暴风雨，择人而噬，让人下意识不想在小问题上激怒他。</p><p>“既然大家没有反对，那就算同意。”路西恩看向老师风暴主宰。</p><p>费尔南多板着脸道：“接下来就按照伊文斯委员说的做。”</p><p>于是路西恩转过身，操纵魔法阵，让投影上只显示最初的公理和公设：</p><p>“涅西卡委员，我问你，这几个公理和公设有错吗？”</p><p>涅西卡条件反射式回答：“这与真实世界不同。”</p><p>“涅西卡委员，忘记外面的阳光，忘记外面的世界，忘记这篇论文后面的内容，你诚实地回答，这几个公理和公设有错误吗？”路西恩厉声喝道。</p><p>涅西卡被路西恩的气势压住，仔细看了看，这不就是高塔几何的五个公理、四个公设，以及列夫斯基提出的假设吗，于是点头回答：“前面的公理和公设没有错误，但最后一个是荒谬的。”</p><p>“这是反证法，你不知道反证法吗？”路西恩再次喝道。</p><p>白色眉毛抖动了一下，涅西卡没办法让自己像个愚昧的白痴，没学过数学的傻瓜：“那没有问题。”</p><p>“你们认为有错误吗？有就勇敢站起来！”路西恩就像在魔法学校上课，面对一位位魔法学徒，气势逼人。</p><p>这怎么可能有错误，其他委员摇了摇头。</p><p>于是路西恩再次投影出几行内容，果然是列夫斯基的论文。</p><p>“米里娜委员，你认为这一段推理有前提和逻辑上的错误吗？”路西恩严厉地目光看向米里娜。</p><p>米里娜起身冷笑：“这与现实不同，找不到……”</p><p>“忘记它们！我说了忘记它们！只考虑前提假设和逻辑演绎，只考虑纯粹的数学问题！”路西恩咆哮着打断了米里娜的话，“告诉我，这一段推理有逻辑上的错误吗？”</p><p>米里娜被咆哮弄得不知该怎么反驳，仔细推导了一遍，摇了摇头道：“没有逻辑上的错误和漏洞，没有将其他等价命题当做条件使用。”</p><p>“很好。”路西恩示意她坐下，接着再次投影出几行，“玛佩尔委员，你认为这一段推理有前提和逻辑上的错误吗？”</p><p>就这样，路西恩一段段地询问，一次次的咆哮，一遍遍地让委员们忘记别的因素，只考虑单纯的公理公设和逻辑演绎问题。</p><p>受着咆哮，听着问题，回答着有没有错误，涅西卡等委员的脸色渐渐开始发青，额头似乎有一点点冷汗泌出，列夫斯基则精神焕发，仿佛路西恩的每一声咆哮，委员们的每一次回答，都在给他注入信心，带来喜悦，而费尔南多则若有所思地点了点头。</p><p>随着论文的最后几行投影出来，路西恩的目光转向涅西卡，声音低沉地道：“涅西卡委员，这一段有没有逻辑演绎的漏洞，有没有前提假设的错误。”</p><p>涅西卡双手紧握，依稀能感觉到掌心的潮湿，他吞咽了一口唾沫，没敢再提现实，略微颤抖地道：“没有漏洞，没有错误。”</p><p>“很好，没有漏洞，没有错误。”路西恩看着六位委员，似乎在自言自语。</p><p>突然，他用最大的声音咆哮起来，仿佛狂风暴雨降临：</p><p>“既然每一处地方都没有错误，那你们告诉我这篇论文究竟错在哪里？！”</p><p>“告诉我，它究竟错在哪里？！”</p><p>米里娜被吓了一跳，下意识回答：“与我们的直观认识和现实经验违……”</p><p>“将它们抛出你的脑子！”路西恩咆哮着打断，“告诉我，从纯粹的数学上讲，从前提假设和逻辑演绎上讲，它究竟错在哪里？”</p><p>“错在哪里？”</p><p>涅西卡、米里娜等人沉默了，不知该怎么回答，不提现实，不提经验认识，确实找不到前提和逻辑上的错误。</p><p>列夫斯基两只手紧紧握起，脑袋微抬，闭上了双眼，满脸的复杂情绪，有喜有悲，有痛苦有希望。</p><p>“路西恩·伊文斯的咆哮真有风暴主宰的气势，不愧是他的学生。”</p><p>“又一个风暴主宰吗？”</p><p>不知为什么，米里娜等人的脑袋里不是思考反驳的话语，而是突然冒出了这些想法。</p><p>费尔南多摇了摇头，好笑地自语：“我可没有私生子啊。”</p><p>路西恩见自己的气势让他们一时组织不起反击，于是乘胜追击，将手中的另外一份论文放入魔法阵中，然后调整魔法阵，将它与列夫斯基的论文共同展示。</p><p>“《非高塔几何解释的尝试》……”米里娜看到了论文的题目，接着阅读了下去。</p><p>论文一页页展示，但不是替换前面的内容，而是环绕会议室，一张张并列地显示。</p><p>涅西卡揉了揉自己眉头，疑惑地道：“用的微分几何知识……”</p><p>玛佩尔、萨尔盖罗等委员也跟着读了起来，读着读着，他们的脸色就变得煞白，一滴滴冷汗从额头滑落，双手差点拿不稳羽毛笔。</p><p>“这是……”列夫斯基跳了起来，仿佛看到魔法女神出现在了自己面前。这是自己新几何学的模型！这是超过了正常想象与直观认识的“双曲面”模型！这是最有力的证明！</p><p>他无声地痛哭着，真真实实地看到了太阳的升起，黑暗的消退，希望的降临。</p><p>突然，又是一篇论文出现，相当简单，用投影的概念，在单位圆上证明了列夫斯基几何与高塔几何的相容，如果高塔几何成立，那列夫斯基几何也成立！</p><p>简洁的推导，美妙的证明，充满了数学的美感，再也没有比它更震撼涅西卡等委员的证据了！</p><p>我没有错，我一直走在正确的道路上！列夫斯基心里疯狂呐喊起来。</p><p>这时，路西恩的声音柔和地在他们耳边响起：“众所周知，我们只能看到一定频率范围内的光，超过了这个范围，我们就无法直接感受到，只能依靠别的工具来判断，而别的工具同样有着极限。”</p><p>由于论文需要的前置数理成果有些没出来，路西恩是自行推导自行给出，比原本的论文复杂了一些，但这不妨碍米里娜等委员看懂，他们一边看，一边听到路西恩的话语，心中油然升起强烈的疑惑，他现在说这个做什么？</p><p>“所以，在特殊布置的光线场景中，我们的眼睛会由于自身的局限被欺骗，从而产生幻觉，这就是部分幻术的原理。”</p><p>虽然疑惑，但涅西卡、列夫斯基等人都点了点头，说得没错。</p><p>路西恩继续声音柔和地说道：“同样的，我们的耳朵也是一样，超过一定范围的音波就无法听到，一定条件下，它会被干扰，会产生幻听。”</p><p>“我们的认识，我们的经验，受限于我们身体和灵魂的构造，会有相当程度的局限性，相信大家都会变形术，变形成不同种类生物后感受到的世界与我们现在感受到的世界相同吗？”</p><p>“不同。”列夫斯基肯定地回答，虽然很多变形术都依赖于生理解剖上的了解，像在知道蝙蝠靠超声波探路而不是眼睛之前，变形成的蝙蝠都有这方面的偏误，但从原始的魔法花纹得到的变形术，依然能让魔法师们部分了解到不同生物感受的世界。</p><p>路西恩微笑起来，看着迷茫的米里娜等人：“那是我们正确，还是它们正确？很显然，这是从不同角度看待同一件事情，大家都正确，都属于事情真实的一部分，因此，我们的经验，我们的认识是有局限的。”</p><p>“而我们的想象力是建立在我们的经验之上，有局限的经验就束缚着我们的想象力，让它不是万能的。探索世界越深入，我们就会发现很多事情我们完全想象不出来，完全违背了我们的直观认识。”</p><p>费尔南多严肃地点了点头，大概明白了路西恩的意思。</p><p>涅西卡、米里娜、列夫斯基等人则还有点迷茫，直直地看着路西恩。</p><p>路西恩抬起右手，表情变得严肃：</p><p>“所以，你的眼睛会欺骗你，你的耳朵会欺骗你，你的经验会欺骗你，你的想象力同样会欺骗你。”</p><p>说到这里，他停顿了一下，在众人的目光里将右手指向投影在墙面的论文，指向那逻辑严密的演绎和结论，低声道：</p><p>“但数学不会。”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light|来设计一款编程语言吧(2)：语法分析</title>
      <link href="2020/11/11/light-2/"/>
      <url>2020/11/11/light-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>上一篇blog介绍了Light语言的词法分析程序，生成的Token串就是语法分析的输入。这篇文章将对Light使用的语法分析器进行一个总结</p><p>语法分析器的目的是将Token串生成抽象语法树(AST)，通过抽象语法树可以很容易的生成目标代码，或者进行代码优化等操作</p><p>任何语言都有其语法，Light的语法遵循LL(1)文法设计，下面介绍基本原理与实现</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><h3 id="1-1-LL-1-文法"><a href="#1-1-LL-1-文法" class="headerlink" title="1.1 LL(1)文法"></a>1.1 LL(1)文法</h3><p>LL(1)文法主要目的是为了解决两个痛点问题：</p><ul><li>回溯问题  </li></ul><p>这是一个非终结符具有多个产生式候选带来的问题</p><p>当一个非终结符用某个候选式进行匹配时，匹配成功可能是暂时的</p><p>如果要遍历所有匹配的可能，在每个多候选式终结符进行匹配时，就要记录下当前等待匹配的符号的位置、当前推导句型中非终结符的位置，和该非终结符选择的产生式的序号</p><p>某次匹配失败后，舍弃某些分析结果，回溯到上一个岔路口，走下一条路尝试</p><p>这会导致语法分析的效率问题，此外，最终分析失败时，没法确定应该在哪个岔路口抛出错误</p><ul><li>左递归问题  </li></ul><p>对于类似 x*y 的文法</p><p><img src="https://img-blog.csdnimg.cn/20190803122821496.png" alt=""></p><p>若定义<code>S → xAy  A → A* | *</code>，那么在进行语法分析时很容易产生左递归：</p><p><img src="https://img-blog.csdnimg.cn/20190803123038201.png" alt=""></p><p>在这种情况下，通过将文法转化成LL(1)文法，可以消除上面的两种现象</p><p>这时需要引入First集与Follow集的概念，这里不再赘述。总的来说，LL(1)文法的限制条件为：</p><p>1) 文法不含左递归</p><p>2) 文法中每一个非终结符 A 的各个产生式的候选首符集不相交，即若 A → α1 | α2 | … | αn<br>FIRST(αi)∩FIRST(αj) = ∅，i ≠ j</p><p>3) 对于文法中的每个非终结符 A，若它的某个候选首符集包含 ε，则 FIRST(αi)∩FOLLOW(A) = ∅</p><p>Light语言的部分文法如下所示：<br></p><pre class="line-numbers language-none"><code class="language-none">INT := [0-9]+Array := [a-zA-Z]*\[INT\]Identifier := [_a-zA-Z]+[_a-zA-Z0-9]*Compare := &gt;|&lt;|==|&gt;=|&lt;=Argument    ---------&gt; Identifier | ArrayFactor      ---------&gt; INTExpression  ---------&gt; Factor [+|-|*|/|Compare Expression]Bool        ---------&gt; [!] Identifier|ExpressionIFStatement ---------&gt; if(Bool) { ; Statement}WhileStatement ------&gt; while(Bool) { ; Statement}FuncStatement -------&gt; func Identifier() { ; Statement}Return      ---------&gt; return INT|IdentifierStatement   ---------&gt; IFStatement | WhileStatement | FuncStatementDeclare     ---------&gt; Identifier = FuncStatement|INTProgram     ---------&gt; Declare { ; Statement}FuncCall    ---------&gt; Identifier([INT]*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="1-2-自上向下的文法分析"><a href="#1-2-自上向下的文法分析" class="headerlink" title="1.2 自上向下的文法分析"></a>1.2 自上向下的文法分析</h3><p>文法分析可以分为自上向下和自下向上，对于Light语言我们采用自上向下的分析方式，同时自上向下的分析主要有递归下降分析和构造LR语法分析表的方法</p><p>在实现文法分析上，我们采用递归下降分析法。<del>主要是为了方便写代码</del></p><p>递归下降分析法被很多编译器采用，如GCC 4.0，LLVM，…</p><p>算法的基本思想是</p><ul><li>每个非终结符构造一个分析函数</li><li>用向前看符号指导产生式规则的规则</li></ul><p>实现方面举个例子，对于一般的语法<br></p><pre class="line-numbers language-none"><code class="language-none">X -&gt; β11 ... β1i   | β21 ... β2j   | β31 ... β3k   | ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>我们写出它的递归下降分析程序：<br><pre class="line-numbers language-none"><code class="language-none">parse_X():    token = nextToken()    switch(token)        case ...:  // β11 ... β1i        case ...:  // β21 ... β2j        case ...:  // β31 ... β3k        ...        default: error("...")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>作为输出对象，首先进行抽象语法树(AST)的构造</p><p>AST可以参考二叉树，与二叉树不同的是，AST可以不只有一个子节点，同时AST的根节点都是非终结符，叶节点都是终结符</p><pre class="line-numbers language-none"><code class="language-none">class SyntaxTree(object):    def __init__(self):        self.root = None        self.current = None    def add_child_node(self, new_node, father=None):        pass    class SyntaxTreeNode(object):    def __init__(self, value=None, _type=None):        self.value = value        self.type = _type        self.father = None        self.left = None        self.right = None        self.first_son = None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来构造<code>match</code>函数，该函数匹配一个token并将指针向后移一位<br></p><pre class="line-numbers language-none"><code class="language-none">def match(self, token):    if self.lookahead[0] == token[0]:        self.lookahead = self.getNextToken()def getNextToken(self):    self.current_token += 1    if self.current_token &gt;= len(self.TOKEN):        return self.EOF    return self.TOKEN[self.current_token]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>下面给出递归下降分析法的实例，例如对算数表达式进行分析</p><pre class="line-numbers language-none"><code class="language-none">parse_E()    parse_T()    match(token)    while(token == +)        parse_T()        match(token)parse_T()    parse_F()    match(token)      while(token == *)        parse_F()        match(token)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他语法的分析也是同样的道理，需要对每一个非终结符都编写一个分析函数，根据输入的Token的类型执行相应的分析函数</p><p>最后执行该语法分析器，生成的语法树如下所示：<br></p><pre class="line-numbers language-none"><code class="language-none">// 源代码func add(a, b){    return a+b}three = add(1, 2)// dfs打印语法树( self: Program None,first_son: FuncStatement, father: None, left: None, right: None )( self: FuncStatement None,first_son: add, father: Program, left: None, right: Declare_func )( self: add FuncStatement_Name,first_son: None, father: FuncStatement, left: None, right: ParameterList )( self: ParameterList None,first_son: a, father: FuncStatement, left: add, right: Statement )( self: a 500,first_son: None, father: ParameterList, left: None, right: b )( self: b 500,first_son: None, father: ParameterList, left: a, right: None )( self: Statement None,first_son: Return, father: FuncStatement, left: ParameterList, right: None )( self: Return None,first_son: Expression, father: Statement, left: None, right: None )( self: Expression None,first_son: a, father: Return, left: None, right: None )( self: a 500,first_son: None, father: Expression, left: None, right: + )( self: + 400,first_son: None, father: Expression, left: a, right: b )( self: b 500,first_son: None, father: Expression, left: +, right: None )( self: Declare_func None,first_son: three, father: Program, left: FuncStatement, right: None )( self: three 500,first_son: None, father: Declare_func, left: None, right: = )( self: = 406,first_son: None, father: Declare_func, left: three, right: FuncCall )( self: FuncCall None,first_son: add, father: Declare_func, left: =, right: None )( self: add FuncCall_Name,first_son: None, father: FuncCall, left: None, right: ParameterList )( self: ParameterList None,first_son: 1, father: FuncCall, left: add, right: None )( self: 1 600,first_son: None, father: ParameterList, left: None, right: 2 )( self: 2 600,first_son: None, father: ParameterList, left: 1, right: None )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light|来设计一款编程语言吧(1)：词法分析</title>
      <link href="2020/11/10/light-1/"/>
      <url>2020/11/10/light-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该系列对Light语言进行一个总结性质的记录，emm勉强算官方文档吧<span class="github-emoji"><span>😝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Light是一款跨平台轻量级的解释型语言，语法借鉴JavaScript，支持条件语句、循环语句，目前变量支持整数类型、函数类型</p><p>完整项目见我的GitHub</p><p>该语言使用实例如下所示：<br></p><pre class="line-numbers language-none"><code class="language-none">##############################################                 Quick start               ##############################################func add(a, b){    return a+b}three = add(1, 2)print(three)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>具体语法规则放在第二篇blog中介绍，下面开始进行词法分析</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>词法分析处于编译原理的第一环节，目的是将源文件转化成可供语法分析的Token串。在该过程中，需要将变量、数字、关键词、分隔符等都识别出来，并制备成Token格式</p><p>先了解一下词法分析的知识关系图</p><p><img src="https://img-blog.csdnimg.cn/20190112203946406.png" alt=""></p><p>开发一个词法分析器是在词法定义的基础上的，词法定义需要使用正则表达式</p><p>正则表达式可以转换为NFA（Non-determinate finite automata 不确定的有穷自动机），NFA可以转换为DFA（determinate finite automata 确定有穷自动机），DFA可以极小化，进而使用为开发词法分析器的工具</p><p>词法分析器有两种识别方法，分别是关联和独立两种形式，这里我们使用独立的形式，即把词法分析当做是一个独立的整体，并将处理好的结果交给下一步来执行。</p><h3 id="1-1-Token"><a href="#1-1-Token" class="headerlink" title="1.1 Token"></a>1.1 Token</h3><p>定义Token如下：</p><div class="table-container"><table><thead><tr><th>KEYWORD</th><th>tokenID</th><th>SEPARATOR</th><th>tokenID</th><th>OPERATOR</th><th>tokenID</th></tr></thead><tbody><tr><td>if</td><td>100</td><td>(</td><td>300</td><td>+</td><td>400</td></tr><tr><td>elif</td><td>101</td><td>)</td><td>301</td><td>-</td><td>401</td></tr><tr><td>else</td><td>102</td><td>[</td><td>302</td><td>*</td><td>402</td></tr><tr><td>while</td><td>103</td><td>]</td><td>303</td><td>/</td><td>403</td></tr><tr><td>break</td><td>104</td><td>{</td><td>304</td><td>&gt;</td><td>404</td></tr><tr><td>func</td><td>105</td><td>}</td><td>305</td><td>&lt;</td><td>405</td></tr><tr><td>return</td><td>106</td><td>:</td><td>306</td><td>=</td><td>406</td></tr><tr><td>———</td><td>———</td><td>;</td><td>307</td><td>&gt;=</td><td>407</td></tr><tr><td>IDENTIFY</td><td>500</td><td>\n</td><td>308</td><td>&lt;=</td><td>408</td></tr><tr><td>INT</td><td>600</td><td></td><td></td><td>==</td><td>409</td></tr></tbody></table></div><p>下面就不一一列举了…</p><p>一个词法单元(Token)由两部分组成，分别是(id, content)，其中</p><ul><li>关键词(KEYWORD)<br>是具有特殊意义的词，不能被其他方式使用</li><li>分隔符(SEPARATOR)<br>分隔语句，产生语义</li><li>操作符(OPERATOR)<br>进行运算与比较</li><li>变量(IDENTIFY)<br>变量可以是函数，也可以是数</li><li>整数类型(INT)<br>定义整数类型</li></ul><h3 id="1-2-DFA"><a href="#1-2-DFA" class="headerlink" title="1.2 DFA"></a>1.2 DFA</h3><p>DFA是确定有穷自动机，使用DFA来生成我们需要的符号，比如生成一个无符号实数的DFA：</p><p><img src="https://img-blog.csdnimg.cn/20190113124130830.png" alt=""></p><p>对于DFA，我们往往需要把它化成最简，然后就可以直接用代码实现了</p><h3 id="1-3-NFA"><a href="#1-3-NFA" class="headerlink" title="1.3 NFA"></a>1.3 NFA</h3><p>词法分析的一般过程是 regular =&gt; NFA =&gt; DFA =&gt; code</p><p>NFA是对正则表达式的直接翻译，DFA 可以认为是一种特殊的 NFA，它最大的特点就是确定性。它的确定性在于，在一个状态下，输入一个符号，一定是转换到确定的状态，没有其他的可能性</p><p>而NFA是不确定的，同样的输入可能有不同的输出，因此需要把NFA转为DFA，转化方法有Thompson算法，这里就不细展开了</p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>对词法分析器进行代码实现，我们首先实现<code>getNextChar</code>函数，该函数的作用是匹配一个字符，并将指针移动到下一个字符<br></p><pre class="line-numbers language-none"><code class="language-none">def getNextChar(self):    self.current_column += 1    if self.current_raw &gt;= len(self.source_code):        return self.EOF    if self.current_column &gt;= len(self.source_code[self.current_raw]):        self.current_raw += 1        self.current_column = -1        return '\\n'    return self.source_code[self.current_raw][self.current_column]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>有时候我们需要向前看一位，<br><pre class="line-numbers language-none"><code class="language-none">def lookahead(self):    ch = self.getNextChar()    self.back()    return ch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>然后我们识别变量(IDENTIFY)，注意到IDENTIFY的DFA图很容易可以画出来，我们定义一个变量首字母必须以字母或下划线开头，然后可以接字母或下划线或数字。如果遇到其他字符（如分隔符或空格），则表示该变量结束匹配<p></p><p>因此画出DFA，代码如下：<br></p><pre class="line-numbers language-none"><code class="language-none">def recognizeId(self, ch):    '''识别标志符 Identity，包括关键词'''    state = 0    str_id = ''    while state != 2:        if state == 0:            if ch.isalpha() or ch == '_':                state = 1                str_id += ch            else:                raise ValueError('Failed to recognizeId ch: {}'.format(ch))        if state == 1:            ch = self.getNextChar()            if ch.isalpha() or ch.isdigit() or ch == '_':                state = 1                str_id += ch            else:                state = 2    #这里需要回退一个字符    self.back()         return str_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>对于注释，我们使用//进行单行注释</p><pre class="line-numbers language-none"><code class="language-none">def recognizeComment(self, ch):    state = 0    str = ''    while state != 3:        if state == 0:            if ch == '/':                state = 1                str += ch            else:                raise ValueError('Failed to recognizeComment ch: {}'.format(ch))        if state == 1:            if ch == '/':                state = 2                str += ch            else:                raise ValueError('Failed to recognizeComment ch: {}'.format(ch))        if state == 2:            ch = self.getNextChar()            if ch != '\\n':                state = 2                str += ch            else:                state = 3    self.back()    return str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他识别同理不再赘述</p><p>最后，使用<code>scanner</code>函数对所有识别方式进行整合，根据得到的不同字符来选择不同的识别方法，并将结果保存在<code>TOKEN</code>列表中<br></p><pre class="line-numbers language-none"><code class="language-none">def scanner(self):    ch = ''    while ch != '\0':        ch = self.getNextChar()        if ch == ' ':            pass        elif ch == '\n':            self.TOKEN.append([Token.TOKENID['\\n'], ch])        elif ch.isalpha() or ch == '_':            Identify = self.recognizeId(ch)            if Token.isKEYWORD(Identify):                self.TOKEN.append([Token.TOKENID[Identify], Identify])            else:                self.TOKEN.append([Token.TOKENID['Identify'], Identify])        elif ch.isdigit():            Integer = self.recognizeInteger(ch)            self.TOKEN.append([Token.TOKENID['INT'], Integer])        elif Token.isOPERATOR(ch):            if ch == '/' and self.lookahead() == '/':                self.recognizeComment(ch)                self.TOKEN.append([Token.TOKENID['\\n'], '\n'])            else:                Op = self.recognizeOp(ch)                self.TOKEN.append([Token.TOKENID[Op], Op])        elif Token.isSEPARATOR(ch):            self.TOKEN.append([Token.TOKENID[ch], ch])        else:            raise ValueError('Failed to scanner ch: {}'.format(ch))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>下面执行该词法分析器，生成TOKEN串如下所示：<br></p><pre class="line-numbers language-none"><code class="language-none">// 源代码func add(a, b){    return a+b}three = add(1, 2)// 生成Token串[[105, 'func'], [500, 'add'], [300, '('], [500, 'a'], [500, 'b'], [301, ')'], [304, '{'], [308, '\n'], [106, 'return'], [500, 'a'], [400, '+'], [500, 'b'], [308, '\n'], [305, '}'], [308, '\n'], [500, 'three'], [406, '='], [500, 'add'], [300, '('], [600, '1'], [600, '2'], [301, ')'], [308, '\n']]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guitar|曲谱</title>
      <link href="2020/11/09/guitar-1/"/>
      <url>2020/11/09/guitar-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近在练习吉他和弦，于是在这里收集一些我自己喜欢的吉他谱，希望能早日弹出流利的曲子<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>以后会在这里继续更新~</p><h2 id="0x01-弹唱曲谱"><a href="#0x01-弹唱曲谱" class="headerlink" title="0x01 弹唱曲谱"></a>0x01 弹唱曲谱</h2><h2 id="指弹"><a href="#指弹" class="headerlink" title="指弹"></a>指弹</h2><h3 id="童话镇"><a href="#童话镇" class="headerlink" title="童话镇"></a>童话镇</h3><p><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432-50.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010433.jpg" alt=""></p><h3 id="成都"><a href="#成都" class="headerlink" title="成都"></a>成都</h3><p><img src="https://jita.lu/uploads/bd0ac235cef4f1b73b2808c2dfdf80d0.gif" alt=""><br><img src="https://jita.lu/uploads/ab3dac461e022c3dd86f590f9a9f650a.gif" alt=""><br><img src="https://jita.lu/uploads/c693fe3b39929628885aeef821740c4a.gif" alt=""><br><img src="https://jita.lu/uploads/a5e099ce81d8a15f26c086bdfb5d434e.gif" alt=""><br><img src="https://jita.lu/uploads/79c12ff7fe220ad20b70c927120227e5.gif" alt=""><br><img src="https://jita.lu/uploads/9fde0538dd4fdf3f3315d285080fc2b4.gif" alt=""></p><h2 id="扫弦"><a href="#扫弦" class="headerlink" title="扫弦"></a>扫弦</h2><h3 id="当你"><a href="#当你" class="headerlink" title="当你"></a>当你</h3><p><img src="https://jita.lu/uploads/fb5575f63a0892715215e097447ab0b8.png" alt=""><br><img src="https://jita.lu/uploads/30d11e5de2d8d27fb4f8e5097b7b656d.png" alt=""><br><img src="https://jita.lu/uploads/e1d51a279f0fce7fc20b2a1f1769e853.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guitar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原理|Vue：MVVM实现</title>
      <link href="2020/10/25/vue-1/"/>
      <url>2020/10/25/vue-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近Vue.js特别火，对于它的mvvm的特性，我感到特别好奇，于是通过尤大的话了解到，Vue使用了JavaScript的 <code>Object.defineProperty</code>函数来实现数据的双向绑定。</p><p>这里，我将记录该方法的学习成果，也算是一个总结吧 ￣へ￣ </p><h2 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>首先看 <code>MDN</code> 上对该方法的描述：<br></p><pre class="line-numbers language-none"><code class="language-none">Object.defineProperty(obj, prop, descriptor)obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。 返回值被传递给函数的对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>创建属性</li></ol><pre class="line-numbers language-none"><code class="language-none">var person = {}// 在对象中添加一个属性与数据描述符的示例Object.defineProperty(person,'age',{    configurable:false,//configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。    enumerable:false,//对象属性是否可通过for-in循环，false为不可循环，默认值为true    writable:false,//对象属性是否可修改,false为不可修改，默认值为true    value:'17' //对象属性的默认值，默认值为undefined});//writableperson.age="71";console.log(person);//17，不可修改value，而且在严格模式下会抛出错误//enumerableperson.name = "Allen"; 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为truefor(var i in person){    console.log(person[i]) //无结果，不可循环}//configurabledelete person.ageconsole.log(person.age)//17，不可删除Object.defineProperty(person,'age',{    configurable:true //不可修改，将抛出错误});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.一般的 Setters 和 Getters</p><pre class="line-numbers language-none"><code class="language-none">function Factory(){var value = null;var factory = [];Object.defineProperty(this, 'temperature',{get: () =&gt; {console.log('get!');},set: val =&gt; {value = val;factory.push(val);}});this.getFactory = () =&gt; factory;}var f = new Factory();f.temperature;//打印 get!f.temperature = 22;f.temperature = 33;console.log(f.getFactory());//打印 [22,33]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当数据获取或者改变时，会调用函数的<code>get</code>或<code>set</code>方法，如此，再辅以视图层的操作，便实现了数据的双向绑定</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>进一步，我们还没有满足：那<code>Vue</code>是如何使用这个方法做到的呢？</p><p>为了解决这个疑问，我们不得不翻开<code>Vue.js</code>的源代码一览究竟</p><p>翻开Vue源代码，可以看到里面普遍使用了<code>Object.defineProperty</code>方法，但是里面拓展了Property来避开<code>Object.defineProperty</code>，其实原理是一样的。如下面<code>Vue</code>的源码片段所示<br></p><pre class="line-numbers language-none"><code class="language-none">// For props and computed properties, we define the proxy getters on// the Vue instances at extension time, on the extended prototype. This// avoids Object.defineProperty calls for each instance created.if (Sub.options.props) {    initProps(Sub)}if (Sub.options.computed) {    initComputed(Sub)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><hr><p>对于Vue来说，它并不是单纯地通过数据和dom节点的绑定来绑定数据，它在网页dom和accessor之间会有两层，一层是Wacher，一层是Directive。如下图所示</p><p><img src="https://img-blog.csdn.net/20180327221231540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjEyOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果我们通过代码修改了<code>a.b</code>的值，那么<code>set</code>函数就会通知Watcher，再由Watcher通知Directive修改Dom里<code>a.b</code>的值</p><h2 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h2><p>那么，如果我们要来实现Vue的功能，代码我们该怎么写呢？这里有一个小小的例子供你参考</p><p>html页面：<br></p><pre class="line-numbers language-none"><code class="language-none">&lt;div id="app"&gt;Hello World!&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>主体部分<br><pre class="line-numbers language-none"><code class="language-none">//模仿Vue操作dom的语法//我们自己创建一个Vue函数const Vue = function({el, data={message:''}}){//绑定 get和set方法Object.defineProperty(this,'message',{get: () =&gt; {return document.getElementById(el).innerHTML},set: val =&gt; {document.getElementById(el).innerHTML = val}})}const v = new Vue({el: 'app',data: {message: 'Wooooooooooo!'}})v.message//返回 Wooooooooooo! 字符串v.message = 'ohhhhhhhhhhh!'//将div内的内容变为 ohhhhhhhhhhh!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样，就能进行数据交互了。<p></p><p>可以看到，所谓各种库和框架，它们并没有在底层层面上创造新的东西，而只是把原有的概念进行了封装与重组。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（3）：线性代数基础</title>
      <link href="2020/10/24/qc-3/"/>
      <url>2020/10/24/qc-3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>传统计算机使用比特 0 和 1 以及它们之间的逻辑操作 and，or，not，xor 等位运算构造加减乘除，并搭建整个经典计算机体系。</p><p>在量子计算机上，基本的存储单元是量子位，即 Qubit。只要搞明白了 Qubit，以及它们之间的逻辑操作，原理上就可以搭建量子计算机。</p><p>Qubit 可以是任意两个本征态<code>|0&gt;</code>和<code>|1&gt;</code>，或者是它们的线性叠加</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>其中<code>α、β</code>是复数</p><p>可以用向量形式来表示狄拉克符号：</p><script type="math/tex; mode=display">\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix},\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}</script><p>在物理意义上，这对应着薛定谔的猫的状态：0——死，1——生。此时这只猫属于既死又活状态，且概率由<code>α、β</code>决定。</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>这里列举的都是最常用的概念，其他的遇到时再查阅资料即可</p><h3 id="1-线性独立"><a href="#1-线性独立" class="headerlink" title="1. 线性独立"></a>1. 线性独立</h3><p>对于一个矢量集$\mathinner{|\alpha_1\rangle},…,\mathinner{|\alpha_n\rangle}\in V$，如果对于复数$c_i$，当且仅当$c_1=…=c_m=0$时，关系式</p><script type="math/tex; mode=display">c_1\mathinner{|\alpha_1\rangle}+...+c_n\mathinner{|\alpha_n\rangle}=0</script><p>才成立，我们称这些矢量线性独立。</p><h3 id="2-内积"><a href="#2-内积" class="headerlink" title="2. 内积"></a>2. 内积</h3><p>$\mathinner{|\alpha\rangle}、\mathinner{|\beta\rangle}$的内积满足以下性质：</p><ul><li>反称：$\mathinner{\langle\alpha|\beta\rangle}=\mathinner{\langle\beta|\alpha\rangle}^*$</li><li>线性：$\mathinner{\langle\alpha|c\beta+d\gamma\rangle}=c\mathinner{\langle\alpha|\beta\rangle}+d\mathinner{\langle\alpha|\gamma\rangle}$</li><li>正定：$\mathinner{\langle\alpha|\beta\rangle}\ge 0$<br>作为例子，我们定义两个矢量$\mathinner{|\alpha\rangle}=(\alpha_1,…,\alpha_n)$和$\mathinner{|\beta\rangle}=(\beta,…,\beta)$在$C^n$中的内积为<script type="math/tex; mode=display">\mathinner{\langle\alpha|\beta\rangle}=\sum_{i=1}^n\alpha_i^*\beta_i</script></li></ul><h3 id="3-模"><a href="#3-模" class="headerlink" title="3. 模"></a>3. 模</h3><script type="math/tex; mode=display">||\mathinner{|\alpha\rangle}||=\mathinner{\langle\alpha|\alpha\rangle}=\sum_{i=1}^n\alpha_i^*\alpha_i</script><p>量子力学把一个物理系统的态和希尔伯特空间中的单位矢量联系起来，在物理现象和数学之间建立了一座桥梁，这个桥梁便是线性代数。</p><h3 id="4-线性算符"><a href="#4-线性算符" class="headerlink" title="4. 线性算符"></a>4. 线性算符</h3><p>一个算符A将矢量$\mathinner{|\alpha\rangle}\in V$映射到另一个矢量$\mathinner{|\beta\rangle}\in V$，即</p><script type="math/tex; mode=display">\mathinner{|\beta\rangle}=A\mathinner{|\alpha\rangle}</script><p>注意到，对量子比特的操作都是通过线性算符实现的。</p><p>在物理意义上，线性算符就是特定波长频率的射线，用来影响量子比特的行为。</p><p>如果对于$\forall \mathinner{|\alpha\rangle}\in V,A\mathinner{|\alpha\rangle}=B\mathinner{|\alpha\rangle}$，则A和B算符是相等的，记为A=B。</p><p>两个线性算符A和B之和C=A+B也是线性的，为</p><script type="math/tex; mode=display">C\mathinner{|\alpha\rangle}=(A+B)\mathinner{|\alpha\rangle}=A\mathinner{|\alpha\rangle}+B\mathinner{|\alpha\rangle}</script><h3 id="5-泡利矩阵"><a href="#5-泡利矩阵" class="headerlink" title="5. 泡利矩阵"></a>5. 泡利矩阵</h3><p>泡利矩阵是经常用到的一种矩阵，</p><script type="math/tex; mode=display">\sigma_x=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix}，\sigma_y=\begin{pmatrix}0 & -i\\ i & 0\\\end{pmatrix}，\sigma_z=\begin{pmatrix}1 & 0\\ 0 & -1\\\end{pmatrix}</script><p>且它有良好的性质：<br>1) $\sigma_x^2=\sigma_y^2=\sigma_z^2=I$ 其中I是单位阵<br>2) $\sigma_x\sigma_y=i\sigma_z，\sigma_y\sigma_z=i\sigma_x，\sigma_z\sigma_x=i\sigma_y$</p><h3 id="6-投影算符"><a href="#6-投影算符" class="headerlink" title="6. 投影算符"></a>6. 投影算符</h3><p>投影算符是用来测量的一种算符，如果$\mathinner{|\alpha\rangle}\in V$是单位矢量，在$\mathinner{|\alpha\rangle}$的一维投影定义如下：</p><script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}=P_\alpha\mathinner{|\gamma\rangle}=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>该算符叫做投影算符，它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p><h3 id="7-么正算符"><a href="#7-么正算符" class="headerlink" title="7. 么正算符"></a>7. 么正算符</h3><p>若</p><script type="math/tex; mode=display">UU^+=U^+U=I</script><p>则称U是么正的，即酉矩阵，从定义中我们知道，U的伴随算符就是它的逆，即</p><script type="math/tex; mode=display">U^+=U^{-1}</script><p>此外，两个么正算符的乘积UV也是么正的，这是量子门串联的基础</p><script type="math/tex; mode=display">(UV)(UV)^+=UVU^+V^+=I</script><p>么正算符的性质非常重要，因为么正算符不改变一个矢量的模，因此么正算符对希尔伯特空间中的矢量的作用，相当于欧几里得空间的坐标旋转。</p><p>所以量子门都是么正算符。</p><h3 id="8-张量积"><a href="#8-张量积" class="headerlink" title="8. 张量积"></a>8. 张量积</h3><p>在希尔伯特空间$\mathcal{H}=\mathcal{H}_1\otimes\mathcal{H}_2$中，对于矢量$\mathinner{|\alpha\rangle}\in\mathcal{H}_1$，$\mathinner{|\beta\rangle}\in\mathcal{H}_2$，都有一个矢量与它们相联系，且后者称为前两者的张量积，记为$\mathinner{|\alpha\rangle}\otimes\mathinner{|\beta\rangle}$</p><p>经常用简写$\mathinner{|\alpha\rangle}\mathinner{|\beta\rangle}，\mathinner{|\alpha\beta\rangle}，\mathinner{|\alpha,\beta\rangle}$来表示张量积</p><h2 id="0x02-单比特系统"><a href="#0x02-单比特系统" class="headerlink" title="0x02 单比特系统"></a>0x02 单比特系统</h2><p>一个量子位可以表示为一个布洛赫球上的向量，对量子位的操作就是旋转这个向量<br><img src="/img/qc-3-1.png" alt=""><br>而旋转操作是用量子门来实现的，要注意的一点是为了满足归一性，量子门必须是酉矩阵</p><p>有一些常用的单量子门，如<code>NOT</code>门</p><script type="math/tex; mode=display">NOT=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix},NOT\mathinner{|0\rangle}=\mathinner{|1\rangle},NOT\mathinner{|1\rangle}=\mathinner{|0\rangle}</script><p><code>NOT</code>门的作用是将量子比特翻转，对应在布洛赫球上的几何意义是将向量翻转</p><h2 id="0x03-多比特系统"><a href="#0x03-多比特系统" class="headerlink" title="0x03 多比特系统"></a>0x03 多比特系统</h2><p>多量子比特之间的关系是用张量积来描述的，比如两量子比特系统有4种基本状态，</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}1\\ 0\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 1\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\1\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\0\\1\\\end{pmatrix}</script><p>对于一般的两量子系统，可写作</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\alpha_{00}\mathinner{|00\rangle}+\alpha_{01}\mathinner{|01\rangle}+\alpha_{10}\mathinner{|10\rangle}+\alpha_{11}\mathinner{|11\rangle}</script><p>而双量子门则为4*4的矩阵，例如CNOT门</p><script type="math/tex; mode=display">CNOT=\begin{pmatrix}1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\0 & 0 & 1 & 0\\\end{pmatrix}</script><p>它的作用是，当控制位为1时，翻转目标位，否则不变。</p><p>代入矩阵运算很容易验证，</p><script type="math/tex; mode=display">CNOT\mathinner{|00\rangle}=\mathinner{|00\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|01\rangle}=\mathinner{|01\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|10\rangle}=\mathinner{|11\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|11\rangle}=\mathinner{|10\rangle}</script><h2 id="0x04-量子纠缠"><a href="#0x04-量子纠缠" class="headerlink" title="0x04 量子纠缠"></a>0x04 量子纠缠</h2><p>一言以蔽之，在线性代数的视角下，量子纠缠就是无法将态分解成张量积的形式。若</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=H_1 \otimes H_2, \exists \mathinner{|\alpha\rangle}\in H_1, \exists \mathinner{|\beta\rangle}\in H_2 s.t. \mathinner{|\varphi\rangle}=\mathinner{|\alpha\rangle}\otimes \mathinner{|\beta\rangle}</script><p>则该量子态不纠缠。举个例子，有两个双量子系统，分别为$\varphi_1$、$\varphi_2$</p><script type="math/tex; mode=display">\mathinner{|\varphi_1\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|11\rangle})</script><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|01\rangle})</script><p>其中$\varphi_1$处于纠缠态，而$\varphi_2$不处于纠缠态，原因在于</p><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}\mathinner{|0\rangle}\otimes (\mathinner{|0\rangle}+\mathinner{|1\rangle})</script><p>$\varphi_2$可以被分解成张量积的形式</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（2）：量子力学基础</title>
      <link href="2020/10/23/qc-2/"/>
      <url>2020/10/23/qc-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-量子力学公理"><a href="#0x01-量子力学公理" class="headerlink" title="0x01 量子力学公理"></a>0x01 量子力学公理</h2><ol><li>每个物理系统都与希尔伯特空间有关。希尔伯特空间是一个向量空间加上一个内积<code>&lt;a|b&gt;</code>，其满足: </li></ol><ul><li>复共轭关系: <code>&lt;a|b&gt; = &lt;b|a&gt;*</code></li><li>线性关系：<code>&lt;x*a1 + y*a2|b&gt; = x&lt;a1|b&gt; + y&lt;a2|b&gt;</code></li><li>正定性：<code>&lt;a|a&gt; ≥ 0</code></li></ul><ol><li>希尔伯特空间中的每一个<code>raw</code>都与系统的一个状态有关。我们有时称这些<code>raw</code>为<code>kets</code>，并给它们贴上标签，如 <code>|φ&gt;</code>。其对偶向量由<code>bras</code>表示，并标记为<code>&lt;φ|</code>。在矩阵表示中，<code>kets</code>是列向量，而<code>bras</code>是<code>kets</code>的共轭转置，是行向量</li><li>每个测量都对应于埃尔米特算子<code>A = A† = AT*</code></li><li>测量的结果可能是<code>A</code>的特征值</li><li>观测到某一特定值的概率为<script type="math/tex; mode=display">Prob(a=a_n) = \frac{<\varphi|P_{a_n}|\varphi>}{<\varphi|\varphi>}</script></li></ol><p>在这里，<code>Pan</code>是对应于给定测量值的状态集(这也被称为A的特征空间)上的投影。这个表达式中的分母是处理状态向量时没有正确归一化的情况</p><h2 id="0x02-测量"><a href="#0x02-测量" class="headerlink" title="0x02 测量"></a>0x02 测量</h2><p>假设我们有一个三维希尔伯特空间由正交基向量组成，<code>|0&gt;,|1&gt;,|2&gt;</code>，因为它们正交，其内积是<code>&lt;0|1&gt;=&lt;0|2&gt;=&lt;1|2&gt;=0，&lt;0|0&gt;=&lt;1|1&gt;=&lt;2|2&gt;=1</code>，取一个希尔伯特空间的特殊状态：</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=\begin{pmatrix}{}\frac{1}{\sqrt{3}}\\\frac{1}{\sqrt{3}}\\\frac{i}{\sqrt{3}}\\\end{pmatrix}</script><p>这种状态是量子叠加的一个例子，其中系统的状态是基状态的和。我们已经使用了<code>bra-ket</code>符号来表示状态，同时也使用了列向量表示状态，其中列向量中的元素对应于bra-ket符号中基向量前面的系数。基向量前面的系数称为振幅，在任何给定的基状态下找到系统的概率由这个基向量振幅的模的平方得到。在上式中，振幅都是1/3  </p><p>注意，使用上面的公理也可以确定这些概率。例如，求找到系统在<code>|0&gt;</code>状态的概率是多少?  </p><p>根据公理5，概率是以投影的形式给出的(我们将忽略分母，因为在标准化的状态下:<code>&lt;φ|φ&gt;=1</code>)，而投影到<code>|0&gt;</code>状态的是算子为：</p><script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=\left(\begin{array}{c}1\\0\\0\\\end{array}\right)\left(\begin{array}{c}1 & 0 & 0\\\end{array}\right)</script><p>同时，</p><script type="math/tex; mode=display">\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=\begin{pmatrix}\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\\end{pmatrix}</script><p>因此我们可以计算出内积</p><script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p><h2 id="0x03-组合量子系统"><a href="#0x03-组合量子系统" class="headerlink" title="0x03 组合量子系统"></a>0x03 组合量子系统</h2><p>很显然不可能只研究一个量子比特的系统，为了进行计算，往往需要研究多量子系统的希尔伯特空间。</p><p>组合的量子系统可以使用kronecker积来表示。</p><p>考虑两个1量子位的希尔伯特空间的集合，那么他们组合的情况一共有4种，分别是<code>{|00&gt;,|01&gt;,|10&gt;,|11&gt;}</code>，每增加一个量子位，可表示的维度便翻一倍。这种组合称为kronecker积（或者张量积）：</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\left(\begin{array}{c}1\\0\\\end{array}\right)\otimes\left(\begin{array}{c}1\\0\\\end{array}\right)=\left(\begin{array}{c}1\\0\\0\\0\\\end{array}\right)</script><p>可见，模拟经典力学是一个难易程度只像粒子数目的多项式一样增加的问题，而模拟量子力学是一个难易程度随粒子数目呈指数级增加的问题</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（1）：体系结构</title>
      <link href="2020/10/21/qc-1/"/>
      <url>2020/10/21/qc-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>　　作为一个工程师，我习惯于对任何看起来神秘的事物刨根问底，量子计算同样如此。看到一辆玩具小车在横冲直撞，我会思考这是因为电池驱动的马达带动轴承做旋转运动；看到日升日落，我会思考这是由于万有引力的束缚，抑或是广义相对论的时空约束。<br>　　万物均有体系结构，就算是看起来最反常识的量子力学，也接受薛定谔方程的描述。因此，我把<code>体系结构</code>作为本系列的第一篇文章，作为对自己知识的梳理。<br>　　或许是我担任”计算机组成与体系结构”这门课程助教的原因:)，体系结构这个话题可以聊的就太多了。然而我毕竟不是搞的芯片，因此本文从工程的角度出发，对比经典与量子两种架构，对其进行一个全面的阐述。  </p><h2 id="0x01-经典架构"><a href="#0x01-经典架构" class="headerlink" title="0x01 经典架构"></a>0x01 经典架构</h2><p>　　首先讨论经典计算机的架构，先从最基本的单元说起。<br>　　经典计算机基本单元是比特0-1，用高电平和低电平来表示。比特的基本处理单元是逻辑门，而逻辑门使用晶体管实现。同时使用晶体管可以来构建存储单元SRAM、DRAM，前者是register、cache的主要成分，后者则是memory的主要成分。同样的，像是CPU中的处理单元加法器、算术逻辑单元等等，这些都可以通过晶体管构成。存储单元和处理单元是可以分开的，所以我们有非常出名的冯诺依曼体系结构，它告诉人们一台计算机可以用什么样的方式搭建出来。  </p><p><img src="/img/qc-1-1.png" alt="Fig. 1: MIPS microarchitecture"></p><p>　　上图是一个极度简化的CPU的组成，它包含几个部分，总的概括便是存储器和算术逻辑单元，为了让存储和运算单元组合到一起工作，于是有一个控制器。这些所有单元都是由晶体管构成，所以我们说，数据的存储、处理、控制都是同质的（homogeneous），因此我们可以把它集成到同一块芯片上来。<br>　　有了这样一个架构，我们就可以在上面运行软件了。比如有一个AI应用，它是用编程语言python来实现的，经过编译器进行编译，生成了二进制文件。这些二进制的指令，便放在处理器上面执行。于是经典计算机自顶向下的流程便结束了。  </p><p><img src="/img/qc-1-2.png" alt="">  </p><h2 id="0x02-量子架构"><a href="#0x02-量子架构" class="headerlink" title="0x02 量子架构"></a>0x02 量子架构</h2><p>　　有了经典架构做铺垫，再看量子环境会有什么不同。首先从最基本的单元说起。量子计算机最基本的单元是量子比特（qubit），而量子比特  </p><script type="math/tex; mode=display">\mathinner{|\phi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>表示该比特有|α|^2的概率为0，否则为1。该量子比特处于0和1的叠加态之中。同理，若有n个qubit则系统同时有2^n个状态的叠加。<br>　　量子计算和经典计算不同的一点在于，量子比特既是数据存储的单元，又是数据处理的单元，因此运算过程就发生在量子比特身上。经典计算机使用逻辑门处理比特，而量子计算机使用量子门来处理。量子门处理的过程是对所有比特进行处理，同时有着巨大的状态空间以及巨大的并行性，因此量子算法效率往往会有指数级别的提升。在简单的介绍之后，下面从工程的角度来看一些实物，一个量子芯片到底该长啥样。  </p><p><img src="/img/qc-1-3.png" alt="">  </p><p>　　上图量子芯片来自荷兰代尔夫特理工大学实验室，它在20mK温度下工作，只有两个量子比特[28]（芯片中央两个黑色圆点）。现探索该量子比特的结构。<br>图1.11(a)则为上图量子芯片中的量子比特放大图，可以看到上极板有3个接口，下极板也有3个接口连接出去，两个极板中间有一层介质，它们共同构成了电容。图1.11(b)是该结构的电路图，图中线条标注了它们之间的对应关系。  </p><p><img src="/img/qc-1-4.png" alt="">    </p><p>　　图中黑色线条相连的部分是电容，红色线条相连的部分是约瑟夫森结（Josephson junction）。这两个约瑟夫森结等效于一个电感，于是这个电路中有了电容、电感，就构成了一个LC振荡电路。那么能量就在电容与电感之间来回震荡。如果用量子电动力学去探索它的基态，可以看到它是一个等分的能级的结构，于是我们可以得到这样一个能量间隔不均匀的能级图：  </p><p><img src="/img/qc-1-5.png" alt="">    </p><p>　　取最低能级为0，取第一激发态为1来作为量子态，这样就构成了一个量子比特。注意在这里，我们观测的是整个约瑟夫森结的状态，也就是说观测的量子状态是宏观的，这就相当于用宏观的表现来观测到了微观的量子状态，所以我们才能操作量子比特。<br>　　有了量子比特后，该怎么对量子比特进行操纵呢，这是通过良好定义的波形来实现的。在图1.10中，可以看到该量子芯片周围有6个接口，这些接口通过导线连接到外部，因此能够通过这些接口把波形传到量子比特上面去。比如说单比特门就用20ns的脉冲，通过接口打在量子比特上面去。<br>　　现在回到上面说的问题，在经典计算机中，存储单元和处理单元是分离的。而在量子计算机中，量子比特既是数据存储的地方，又是数据处理的地方，控制媒介则是模拟波形（模拟信号）。经典电路控制媒介则是数字信号。在经典的架构中，有了CPU便可以直接安装软件运行，而在量子计算机中，由于它们是异构的（同时存在模拟/数字信号），则需要一个专门的控制器来进行沟通转换。就是说在软件和量子比特之间一定要引入一个控制器。  </p><p><img src="/img/qc-1-6.png" alt="">    </p><p>　　上图中，AWG（Arbitrary waveform generator）是任意波形发生器的缩写，用它来发射定义好的模拟波形来操作量子比特。Data Collection Card（数据采集卡）用来采集测量量子比特后返回的结果，这个测量结果也是模拟信号，所以要对模拟信号进行识别从而判断结果是0还是1。整个流程便是PC机软件控制发出数字波形，然后控制器中的AWGs发出定义好的模拟波形打在量子比特上，最后测量结果返回给数字采集卡，数字采集卡判断结果后返回给PC主机。这是过去主流的控制量子比特的方法，也是目前少数实验室采用的方法，但是它是不可扩展的，因此后面会提到全栈量子计算机的架构。<br>　　现在可以比较经典计算和量子计算的不同了：  </p><ol><li>从数据流过程上。经典计算是把数据流拿出来运动，经过一个个函数/运算模块中处理，最后得到结果。所以是数据在动，操作不动。而量子计算中，所有数据保存在量子比特上面，我们把操作一个个的打上去，所以是数据不动，操作在动。这种不同也决定了量子计算机的体系结构和经典是不同的。  </li><li>从编程语言上。经典计算发展到现在，有无数编程语言能够满足经典计算的使用。为了描述与操作量子比特，现在也有很多量子高级语言（如Qiskit），然而这些语言经典算法中的高级特性，如递归等操作并没有很好的实现。在使用量子高级语言的时候，更多的是考虑如何实现电路图，这对于量子算法的产生是个很不利的因素。  </li></ol><p>　　在图1.13控制方法中，控制流程是不可扩展的，因此现在主流的组成如下图所示  </p><p><img src="/img/qc-1-7.png" alt="">  </p><p>　　最上层是一些量子算法，如shor算法等等；中间一层是编程语言和编译器，如Qiskit、Q#、QPanda等等；再下面是要转化成的指令集，如eQASM、OpenQASM；最下层便是量子芯片，可能是超导芯片、离子阱等等。<br>　　接下来看看IBM对它的物理实现：  </p><p><img src="/img/qc-1-8.png" alt="">  </p><p>　　上图(a)就是IBM展示的量子计算机，(b)是封装起来的样子，其内部是一个大号的“冰箱”，芯片要求在20mK的温度下工作。    </p><h2 id="0x03-现在-amp-未来"><a href="#0x03-现在-amp-未来" class="headerlink" title="0x03 现在&amp;未来"></a>0x03 现在&amp;未来</h2><p>　　上面说了那么多过去的知识，接下来看看现在此刻的芯片所处的时代~<br>　　学术界预计在未来几年内，我们将进入有噪声中间量子(Noisy Intermediate-Scale Quantum,NISQ)时代，届时具有数十到数百个量子位元的QC器件将面世。<br>　　虽然量子位的数量不足以构成量子纠错(QEC)，但它仍然被期望使用超出可用的经典计算机的能力，来解决现实世界的问题。<br>　　在NISQ时代，由于技术的限制，量子软件和硬件之间存在差距。当前最流行的电路模型设计一个量子程序时，总是假设量子位和量子操作是完美的，你可以应用任何量子物理操作。但在NISQ硬件上，量子位的相干时间有限，量子运算也不完美。下图是 IBM Q20 芯片，可以看到其参数如图  </p><p><img src="/img/qc-1-9.png" alt="Fig. 2:  IBM Q20 Tokyo Information">  </p><p>　　上图显示了有关IBMQ 20芯片的信息，量子比特的平均寿命仅仅约为50µs，同时量子门之间的操作也有错误率，这意味着该芯片将无法运行大规模的程序。量子比特被放置在一个平面几何体上，由于芯片上的放置和路由限制，耦合器只能将一个量子比特连接到相邻的量子比特上。<br>　　有学者估计，要使量子计算机达到通用计算机的程度，至少需要数十万个量子比特，而当前的进展仅仅是几十个比特。或许将量子计算机作为专用计算才是未来的方向，毕竟从理论到实践的路还很漫长…<br>　　事实上，如今的量子计算机是作为云的形式提供服务的，因为目前最流行的超导体系结构无法在室温下工作，所以只能通过提供API的方式调用。这是不是很像云计算？这也是实验室之外唯一能够使用量子芯片的方法了，目前国外有IBM提供的免费量子芯片可供使用（虽然才5比特…），并且需要排队才能申请到使用权限。    </p><p>　　PS：前两天习大大提出要发展量子科技，难道这个冷门中的冷门方向要出头了吗？！惊了！</p><blockquote><p>Reference<br>[1] John Preskill. Quantum computing in the nisq era and beyond. arXiv preprint arXiv:1801.00862, 2018.<br>[2] Sergio Boixo, Sergei V Isakov, Vadim N Smelyanskiy, Ryan Babbush, Nan Ding, Zhang Jiang, Michael J Bremner, John M Martinis, and Hartmut Neven. Characterizing quantum supremacy in near-term devices. Nature Physics, 14(6):595, 2018.<br>[3] IBM. IBM Q Experience Device. <a href="https://quantumexperience.ng.bluemix">https://quantumexperience.ng.bluemix</a>. net/qx/devices, 2018.<br>[4] Li G, Ding Y, Xie Y. Tackling the qubit mapping problem for NISQ-era quantum devices[C]//Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems. 2019: 1001-1014.  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我常用的一些学术资源</title>
      <link href="2020/10/21/xue-zhu-zi-yuan/"/>
      <url>2020/10/21/xue-zhu-zi-yuan/</url>
      
        <content type="html"><![CDATA[<p>不定期更新~<span class="github-emoji"><span>😗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f617.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="0x01-论文相关"><a href="#0x01-论文相关" class="headerlink" title="0x01 论文相关"></a>0x01 论文相关</h2><ul><li>sci-hub可用链接<ul><li><a href="https://sci-hub.shop/">备用1</a></li><li><a href="https://sci-hub.ren/">备用2</a></li><li><a href="https://gfsoso.99lb.net/sci-hub.html">一个综合工具，都不行就用这个</a></li></ul></li><li><a href="http://www.letpub.com.cn/index.php?page=journalapp">中科院分区</a><ul><li>查询论文的级别很好用</li></ul></li><li><a href="http://pss-system.cnipa.gov.cn/sipopublicsearch/portal/uiIndex.shtml">专利检索</a><h2 id="0x02-软件"><a href="#0x02-软件" class="headerlink" title="0x02 软件"></a>0x02 软件</h2></li><li>常用软件的安装<ul><li><a href="http://lookdiv.com/">webstrom激活</a></li><li><a href="https://blog.csdn.net/Slatter/article/details/88730542?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">matlab 2018a</a></li></ul></li></ul><h2 id="0x03-实用网站"><a href="#0x03-实用网站" class="headerlink" title="0x03 实用网站"></a>0x03 实用网站</h2><ul><li><a href="https://www.wolframalpha.com/">wolframalpha</a><ul><li>非常好用的数学计算工具，nice！<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>可识别自然语言，功能非常齐全</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
