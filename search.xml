<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可计算理论</title>
      <link href="2021/03/29/ke-ji-suan-li-lun/"/>
      <url>2021/03/29/ke-ji-suan-li-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本文旨在讨论可计算理论的来源、定义以及应用。</p><p>先贴一段wiki的原文：</p><blockquote><p>Computability theory, also known as recursion theory, is a branch of mathematical logic, computer science, and the theory of computation that originated in the 1930s with the study of computable functions and Turing degrees. The field has since expanded to include the study of generalized computability and definability. In these areas, recursion theory overlaps with proof theory and effective descriptive set theory</p></blockquote><p>可计算理论又称递归理论，在计算机科学中，可计算理论是计算理论的一个分支，研究不同的计算模型下算法问题如何被有效解决。与之相对应的，计算复杂性理论讨论一个问题怎样被有效的解决。</p><h2 id="0x01-来源"><a href="#0x01-来源" class="headerlink" title="0x01 来源"></a>0x01 来源</h2><p>计算机科学总是关注计算机能够做什么，而可计算理论关注计算机的局限性，以及计算机不能做什么。</p><p>可计算性最初的定义由图灵（Turing）和丘奇（Church）给出，</p><p><em>定义1（图灵论点）：可计算的函数和可用图灵机计算的函数等同</em></p><p>图灵机由读写头、一根无限长的纸带、一套控制规则、一个状态寄存器构成。图灵机的状态是有限的，并且有一个特殊的停机状态，由此引申出了停机问题。</p><p><em>定义2（丘奇论点）：可计算的函数和<script type="math/tex">\lambda</script>可定义的函数相同</em></p><p>丘奇的观点是借助一个语法极其简单但功能强大的<script type="math/tex">\lambda</script>函数</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Computability_theory">https://en.wikipedia.org/wiki/Computability_theory</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020总结</title>
      <link href="2021/01/02/2020-zong-jie/"/>
      <url>2021/01/02/2020-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>如题，对2020年的一个年度总结，在这里请恕我晒出新年收到的第一份惊喜，当当当当~<span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="/img/heart.jpg" width="50%" height="50%" alt="此处应@美美" align="center"></p><p>表扬一下 <em>@美美</em> 的画工，奖励一朵小红花~</p><h3 id="去年都发生了些啥？"><a href="#去年都发生了些啥？" class="headerlink" title="去年都发生了些啥？"></a>去年都发生了些啥？</h3><p>看到这个小标题的时候，我蒙了一下，不禁陷入了回忆之中。去年发生了太多的事情，从年初因为疫情开始在家上了一学期网课，到年末还是因为疫情封校，疫情成为贯穿了一年的主旋律。</p><p>因为上网课赋闲在家，整个上半年我始终是焦虑的，然而懒癌患者的我深陷于主观能动性不及客观规律的进程之中，说人话就是：懒癌没治了。沉迷于键政的我于是就这么在走走停停中，终于九月份开学了！</p><p>开学后的一段时间，我陷入了迷茫期，整天愁的是毕业与出路的问题，再加上那段时间感情不顺，于是我找了学校的心理老师给自己做辅导。在这里点赞心理老师，因为老师真的很温柔~然后又联系了过去的朋友们出去玩，犹记得当时在 <em>@ysh</em> 的带领下到太古里的阁楼上喝茶，外面的雨淅淅沥沥。</p><p>总而言之，当时那段最痛苦的时期挺过去了，接下来是不是就该拨开云雾见青天了？</p><h3 id="感觉自己棒棒哒！"><a href="#感觉自己棒棒哒！" class="headerlink" title="感觉自己棒棒哒！"></a>感觉自己棒棒哒！</h3><p>这一小节就对自己做一个盘点吧！首先是被老板压了一年的小论文终于发了，达到了毕业条件的我开心得在食堂连吃了两碗饭~然后12月份又申请了一个专利，这其中有一点小小的遗憾，以后有机会再表。</p><p>前两周和朋友 <em>@kh</em> 闲聊时，他突然问我，你觉得读研究生最大的收获是什么？</p><p>我觉得应该是收集信息的能力吧。刚入学时老板放了一个完全陌生的课题让我去做，没有可以学习模仿的师兄，也没有可以讨论的对象。于是我只有日复一日的阅读文献，了解学术界最新的进展。然而不幸的是，拿到一篇文章往往牵涉出很多未知的概念与前置知识，于是从参考文献出发，从引用与被引用出发，把这一条”链表“上的知识树全都点亮，在叶节点的位置就是目前人类知识的边界区域了。现在想想，自己看文章的时间要远大于构思作文的时间，但是在这种条件下，我也学会了诸如 <em>sci-hub</em> 这类神器的使用。总的来说，这一段过程是枯燥又有趣的，经常会有”这样也行？！“的感叹，让人不得不感叹世界上的聪明人是如此之多。</p><p>多年以后，至少有一点是我值得欣慰的：诸如<em>某某保健品富含氨基酸</em>这类骗局是对我无效了。</p><p>话收回来，今年我学会了些什么呢？我想从<strong>学业</strong>与<strong>理财</strong>两方面说起。</p><p>首先我学会了专利的写法，有一点感慨就是专利是真的很好写了，入门难度比论文低了一个数量级，怪不得大家都想申请专利<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。 这里需要感谢 <em>@syunk</em> 的帮助，在写的过程中，但凡我有不懂的我就会去询问他的意见，他也不厌其烦帮我解答，总之感谢~</p><p>由于各种原因，我准备找工作&amp;实习了，目前正在恶补已经遗忘的基础知识和面经，总之希望今年秋招能有一个不留遗憾的结局啦~在这里许个愿，希望考的全会，钱多事少离家近！</p><p>说到理财的话题，今年我光荣的成为了一名小韭菜！和大佬 <em>@阿洋</em> 不同，我就只敢玩玩指数型基金，不过今年韭菜涨势不错，第一次赚了一点小钱：</p><p><img src="/img/jj.jpg" width="50%" height="50%" alt="一只韭菜的成长" align="center"></p><p>当我亲眼所见白酒上涨时我没有跟，因为我觉得白酒不值这个价钱，全都是泡沫；当我看白酒继续涨时我也没有跟，因为当菜市场大妈都知道买白酒时，就是它跌的时候了；后来白酒一涨再涨，我坐不住了，真香！酱香型科技名不虚传！</p><p>对于基金我向来是买了就不看，避免心脏出现心电图反应，主要是初涉这个领域，还有很多地方需要学习。顺便一提上图并不是白酒，而是白酒医药混合股，在这里得避免打广告误导的嫌疑…</p><p>现在想想自己还是心大，没有吃亏算我运气好，未来打算多问问 <strong>金融之神、基金与股票的王者、火焰与风暴的主宰</strong> <em>@美美</em> 的意见，反正不会再盲投了<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="最后的一些话"><a href="#最后的一些话" class="headerlink" title="最后的一些话"></a>最后的一些话</h3><p>过去的一年，如果用一个字来概括，我会选择“转”字。从迷茫失意再到守得云开见月明，这一年经历了太多太多。</p><p>起承转合，今年该轮到“合”了。</p><p>写在最后作为结尾，就放下过去的一年里我最喜欢的一句话吧：</p><blockquote><p>愿卿不为生计走<br>愿卿不为稻粱谋<br>愿卿终遂平生愿<br>愿卿忘却世间愁  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript|面向对象</title>
      <link href="2020/12/24/js-oo/"/>
      <url>2020/12/24/js-oo/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是一门面向对象的语言，而面向对象有三大特性：封装、多态和继承。</p><p>在es5及以前，继承的特性是通过原型链实现的，这种方法繁琐又复杂，且有各自的问题。因此，es6新增了 <code>class</code> 关键词语法糖，虽然原理没变，依旧是利用原型链实现的类方法，却更简单直观了。</p><p><code>class</code> 其实是一种特殊的函数，同是JavaScript世界中的一等公民。</p><p>对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象  </p><ul><li>工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个 对象。这个模式在构造函数模式出现后就很少用了。</li><li>使用构造函数模式可以自定义引用类型，可以使用 <code>new</code> 关键字像创建内置类型实例一样创建自 定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到 函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。</li><li>原型模式解决了成员共享的问题，只要是添加到构造函数 <code>prototype</code> 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。</li></ul><p>在原型模式下，还得首先聊聊 <code>prototype、__proto__、constructor</code> 之间的关系，这也是实现面向对象的基础。</p><p><img src="/img/js-prototype.png" alt="出自https://blog.csdn.net/cc18868876837/article/details/81211729"></p><p>我们需要牢记两点： </p><ol><li><code>__proto__</code> 和 <code>constructor</code> 属性是对象所独有的； </li><li><code>prototype</code> 属性是函数所独有的，因为函数也是一种对象，所以函数也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性。 </li></ol><p><code>__proto__</code> 属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的 <code>__proto__</code> 属性所指向的那个对象（父对象）里找，一直找，直到 <code>__proto__</code> 属性的终点null，然后返回undefined，再往上找就相当于在null上取值，会报错。通过 <code>__proto__</code> 属性将对象连接起来的这条链路即我们所谓的原型链。另外 <code>__proto__</code> 属性是浏览器对es5的实现，而不是es标准。</p><p><code>prototype</code> 属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即 <code>f1.__proto__ === Foo.prototype</code>。</p><p><code>constructor</code> 属性的含义就是指向该对象的构造函数，所有函数的构造函数都指向Function本身。 </p><p>下面给出代码示例：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params">name</span>)</span>{<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.sayname = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>    }<br>}<br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> F(<span class="hljs-string">'Alice'</span>)<br></code></pre></td></tr></tbody></table></figure><p></p><p>在 <code>new</code> 操作符调用构造函数时会执行如下操作：</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的 <code>[[Prototype]]</code> 特性被赋值为构造函数（就是指向该函数本身）的 <code>prototype</code> 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p>因此 <code>f.__proto__ === F.prototype</code> </p><p>所有对象的 <code>prototype</code> 的 <code>__proto__</code> 都指向上一级的 <code>prototype</code>，Function的上一级是Object，自定义函数的上一级也是Object。<br></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 以下均为true</span><br><br>console.log(f.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype)   <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype)    <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype)   <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype)   <br></code></pre></td></tr></tbody></table></figure><p></p><p>每个函数都有一个 <code>prototype</code> 属性（函数独有），<code>prototype</code> 属性里有两个属性，分别是：<code>constructor、__proto__</code>，其中，<code>constructor</code> 就是本身，两者循环引用。</p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">console</span>.log(<span class="hljs-type">F</span>.proto<span class="hljs-keyword">type</span>.constructor === <span class="hljs-type">F</span>) <br><span class="hljs-title">console</span>.log(f.constructor === <span class="hljs-type">F</span>.proto<span class="hljs-keyword">type</span>.constructor)<br></code></pre></td></tr></tbody></table></figure><p>每次调用该函数的构造方法创建一个实例的时候，这个实例内部的[[prototype]]指针就会被赋值为构造函数的<code>prototype</code>，在Firefox、Safari、Chrome的编译器中，这个<code>[[prototype]]</code>指针被实现为<code>__proto__</code>。</p><p>当对象遇到自己作用域内没有的属性或方法时，就会沿着原型链上找，如：<br>调用 <code>F.hasOwnProperty('name')</code> ，会调用 <code>F.prototype.__proto__.hasOwnProperty</code> 方法<br>默认情况下，所有引用类型都继承自<code>Object</code>，包括所有函数，因此 <code>F.prototype.__proto__</code> 就是 <code>Object.prototype</code>。<br></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>hasOwnProperty<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span></span>hasOwnProperty, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>has<span class="hljs-constructor">OwnProperty('<span class="hljs-params">name</span>')</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span></span>hasOwnProperty.call(F, 'name'))  <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype) <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype)  <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype) <br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype) <br></code></pre></td></tr></tbody></table></figure><p></p><p><strong>继承</strong>  </p><p>暂时不考虑es6提供的 <code>extends</code> 关键词，实现继承的方式有很多，但是各有各的缺点：</p><ul><li><p>原型链继承</p><ul><li>原型中包含的引用值会在所有实例间共享</li><li>子类型在实例化时不能给父类型的构造函数传参</li></ul></li><li><p>盗用构造函数</p><ul><li>必须在构造函数中定义方法，因此函数不能重用</li><li>子类也不能访问父类原型上定义的方法</li></ul></li></ul><p>最常用的是组合继承，结合了两者的优点。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 原型继承</span><br><span class="hljs-keyword">function</span> extend<span class="hljs-constructor">_F()</span>{}<br>extend_F.prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span>  <br><br><span class="hljs-comment">//盗用构造函数</span><br><span class="hljs-keyword">function</span> extend<span class="hljs-constructor">_F()</span>{<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>call(this)<br>}<br><br><span class="hljs-comment">//组合继承</span><br><span class="hljs-keyword">function</span> extend<span class="hljs-constructor">_F()</span>{<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>call(this)<br>}<br>extend_F.prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span> <br></code></pre></td></tr></tbody></table></figure><p>ES5的继承时通过<code>prototype</code>或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）。</p><p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。</p><p>在有了<code>extends</code>关键词后，子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p><p>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结|常用算法</title>
      <link href="2020/12/16/leet-algo/"/>
      <url>2020/12/16/leet-algo/</url>
      
        <content type="html"><![CDATA[<p>总结一下经常出现 或 巧妙的算法~</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode 28 implement-strStr</a><br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">haystack</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">needle</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">{number}</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> strStr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">haystack, needle</span>) </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateNext</span>(<span class="hljs-params">needle</span>)</span>{<br>        <span class="hljs-keyword">let</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(needle.length), x = <span class="hljs-number">1</span>, now = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">x &lt; needle.length</span>)</span>{<br>            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">needle[now] === needle[x]</span>)</span>{<br>                now += <span class="hljs-number">1</span><br>                next[x] = now<br>                x++<br>            }<span class="hljs-keyword">else</span>{<br>                <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">now &gt; <span class="hljs-number">0</span></span>)</span>{<br>                    now = next[now-<span class="hljs-number">1</span>]<br>                }<span class="hljs-keyword">else</span>{<br>                    next[x] = <span class="hljs-number">0</span><br>                    x++<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> next<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">core</span>(<span class="hljs-params">haystack, needle</span>)</span>{<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">needle == haystack</span>)</span>{<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        }<br>        <span class="hljs-keyword">const</span> next = generateNext(needle)<br>        <span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">p1 &lt; haystack.length &amp;&amp; p2 &lt; needle.length</span>)</span>{<br>            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">haystack[p1] === needle[p2]</span>)</span>{<br>                p1++<br>                p2++<br>            }<span class="hljs-keyword">else</span>{<br>                <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">p2 &gt; <span class="hljs-number">0</span></span>)</span>{<br>                    p2 = next[p2-<span class="hljs-number">1</span>]<br>                }<span class="hljs-keyword">else</span>{<br>                    p1++<br>                }<br>            }<br>        }<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">p2 == needle.length</span>)</span>{<br>            <span class="hljs-keyword">return</span> p1-p2<br>        }<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <br>    }<br><br>    <span class="hljs-keyword">return</span> core(haystack, needle)<br>};<br></code></pre></td></tr></tbody></table></figure><br>奇淫巧技: 使用js内置方法<br><figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> strStr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(haystack, needle)</span> </span>{<br>    <span class="hljs-keyword">return</span> haystack.search(needle)<br>};<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">leetcode-42-接雨水</a><br></p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param {number[]} height</span><br><span class="hljs-comment"> * @return {number}</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-built_in">var</span> trap = function(<span class="hljs-built_in">height</span>) {<br>    const stack = [[<span class="hljs-built_in">height</span>[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>]]<br>    <span class="hljs-built_in">let</span> v = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">length</span>; i++){<br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-built_in">length</span>&gt;<span class="hljs-number">0</span> &amp;&amp; stack[stack.<span class="hljs-built_in">length</span>-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&lt;<span class="hljs-built_in">height</span>[i]){<br>            <span class="hljs-built_in">let</span> cur = stack.<span class="hljs-built_in">pop</span>()<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">length</span> === <span class="hljs-number">0</span>){<br>                <span class="hljs-built_in">break</span><br>            }<br>            <span class="hljs-built_in">let</span> top = stack[stack.<span class="hljs-built_in">length</span>-<span class="hljs-number">1</span>]<br>            <span class="hljs-built_in">let</span> h = Math.<span class="hljs-built_in">min</span>(<span class="hljs-built_in">height</span>[i], top[<span class="hljs-number">0</span>]) - cur[<span class="hljs-number">0</span>]<br>            v += h*(i-top[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>)<br>        }<br>        stack.<span class="hljs-built_in">push</span>([<span class="hljs-built_in">height</span>[i], i])<br>    }<br>    <span class="hljs-built_in">return</span> v<br>};<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="并查集（加权）"><a href="#并查集（加权）" class="headerlink" title="并查集（加权）"></a>并查集（加权）</h3><p><a href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个量子计算机</title>
      <link href="2020/12/14/qsim/"/>
      <url>2020/12/14/qsim/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近量子计算很火的样子，作为一个学计算机的，我们不妨自己做一个量子计算机<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>所谓的量子计算机，就是控制一系列量子比特的演化过程，对其施以酉变换，通过测量得出结果的装置。</p><p>在量子计算中，线路模型和图灵机模型理论上是等价的，最常用的量子计算模型便是线路模型，除此之外还有基于测量的模型，而前者比后者更直观简单，这也是我们选择用线路模型来实现的原因了。</p><p>下面我们用经典计算机来模拟量子计算的过程，实现一个量子计算模拟器（玩具版）。</p><h2 id="量子比特"><a href="#量子比特" class="headerlink" title="量子比特"></a>量子比特</h2><p>经典计算机使用比特进行计算，量子计算机就有量子比特，而单量子比特的矩阵表示有：</p><script type="math/tex; mode=display">\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix},\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}</script><p>对于多量子比特，则是单量子比特之间进行kronecker积：</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}1\\ 0\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 1\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\1\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\0\\1\\\end{pmatrix}</script><p>可以看到，对于2个比特的系统，向量的维度是4，而对于n个比特的系统，向量的维度就是$2^n$。可以做一个简单的估计，假设我们使用复数存储一个数字，计算它占据的大小<code>sys.getsizeof(c)</code>为32个字节，也就是说对于10比特的量子计算机，存储状态的空间就有32KB，对于20比特需要32MB，而30个量子比特就需要32GB，再往下就超出了个人计算机的极限了。</p><p>由于维度是指数级的增加，因此在经典计算机上只能进行有限的模拟，2018年一篇顶刊使用超级计算机（天河二号）模拟了超过50个量子比特，这已经是很大的进步了。当然，我们这里只是个玩具量子计算机 :)</p><p>首先引入需要的包：<br></p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-title">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> normalize<br></code></pre></td></tr></tbody></table></figure><br>现在生成初态的量子比特，1位比特维度是2，n位比特维度是$2^n$，使用kronecker积对比特维度进行计算。<p></p><p>定义 <code>basis</code> 方法得到kronecker积：<br></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">def basis(<span class="hljs-built_in">string</span>=<span class="hljs-string">'00000'</span>):<br>    spin_up = np.array(<span class="hljs-string">[[1, 0]]</span>).T<br>    spin_down = np.array(<span class="hljs-string">[[0, 1]]</span>).T<br>    bit = [spin_up, spin_down]<br>    res = np.array(<span class="hljs-string">[[1]]</span>)<br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">string</span>[::<span class="hljs-number">-1</span>]:<br>        res = np.kron(bit[int(idx)], res)<br>    <span class="hljs-keyword">return</span> np.matrix(res)<br></code></pre></td></tr></tbody></table></figure><br>打开 <code>jupyter</code> 测试一下，生成4个量子比特 <code>0100</code> 的初态：<br><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">amplitudes</span> = basis(<span class="hljs-string">'0100'</span>).A1<br></code></pre></td></tr></tbody></table></figure><br>打印 <code>amplitudes</code>:  <p></p><p><code>[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</code> </p><p><strong>如果想生成任意振幅的量子比特呢？</strong></p><p>在一个量子系统中，波函数可以写作：</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle} = \sum_{i=0}^{2^n-1}\alpha_i\mathinner{|i\rangle} \quad s.t. \sum_{i=0}^{2^n-1}\alpha_i^2 = 1</script><p>其中$\alpha_i$是振幅，$\mathinner{|i\rangle}$是基底，它们乘积之和就得到了一个叠加的波函数。</p><p>于是可以定义波函数 <code>wave_func</code><br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wave_func</span>(<span class="hljs-params">coef=[], seqs=[]</span>):</span><br>    <span class="hljs-string">'''返回由振幅和几个Qubit序列表示的叠加态波函数'''</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(coef):<br>        res += a * basis(seqs[i])<br>    <span class="hljs-keyword">return</span> np.matrix(res)<br></code></pre></td></tr></tbody></table></figure><br>测试一下，生成量子叠加态 $\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}(\mathinner{|00\rangle}+\mathinner{|01\rangle}+\mathinner{|11\rangle})$:<br><figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lsl">coef = [np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>), np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>), np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)]<br>amplitudes = wave_func(coef=coef, seqs=['<span class="hljs-number">00</span>','<span class="hljs-number">01</span>','<span class="hljs-number">11</span>']).A1<br></code></pre></td></tr></tbody></table></figure><br>打印 <code>amplitudes</code>: <p></p><p><code>[0.57735027 0.57735027 0.         0.57735027]</code> </p><p>注意到，这种表示方法非常的不友好，简直不是人读的！于是我们尝试对波函数在投影方向进行分解。</p><p>这里我们有投影算符：</p><script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}=P_\alpha\mathinner{|\gamma\rangle}=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p><p>先进行前置的准备工作：Hilbert空间是一个内积空间，所有量子比特都在Hilbert空间内。</p><p>定义生成 <code>Hilbert空间</code> 函数：</p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def hilbert_space(nbit=<span class="hljs-number">5</span>):<br>    nspace = <span class="hljs-number">2</span> ** nbit<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nspace):<br>        # bin(<span class="hljs-number">7</span>) = <span class="hljs-number">0b100</span><br>        binary = bin(i)[<span class="hljs-number">2</span>:]<br>        nzeros = nbit - len(binary)<br>        yield '<span class="hljs-number">0</span>' * nzeros + binary<br></code></pre></td></tr></tbody></table></figure><p>再沿投影方向分解，投影的方向就是基向量的方向：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">project</span>(<span class="hljs-params">wave_func, direction</span>):</span><br>    <span class="hljs-string">'''&lt;Psi | phi_i&gt; to get the amplitude'''</span><br>    <span class="hljs-keyword">return</span> wave_func.H * direction<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decompose</span>(<span class="hljs-params">wave_func</span>):</span><br>    <span class="hljs-string">'''将叠加态波函数分解'''</span><br>    nbit = <span class="hljs-built_in">int</span>(np.log2(<span class="hljs-built_in">len</span>(wave_func)))<br>    amplitudes = []<br>    direct_str = []<br>    <span class="hljs-keyword">for</span> seq <span class="hljs-keyword">in</span> hilbert_space(nbit):<br>        direct = basis(seq)<br>        amp = project(wave_func, direct).A1[<span class="hljs-number">0</span>]  <span class="hljs-comment">#A1 属性将矩阵转化为 1 维 numpy 数组</span><br>        <span class="hljs-keyword">if</span> np.linalg.norm(amp) != <span class="hljs-number">0</span>:<br>            amplitudes.append(amp)<br>            direct_str.append(seq)<br>    <span class="hljs-keyword">return</span> amplitudes, direct_str<br></code></pre></td></tr></tbody></table></figure><br>定义函数<code>a2wf</code>将 振幅 转为能被 <code>print_wf</code> 函数解析的 <code>wave_func</code> 格式<br><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a2wf</span><span class="hljs-params">(amplitudes, n)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">return</span> np.mat(amplitudes.reshape(<span class="hljs-number">2</span> ** n, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><br>再使用 <code>print_wf</code> 函数打印出波函数<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_wf</span>(<span class="hljs-params">wf</span>):</span><br>    coef, seqs = decompose(wf)<br>    <span class="hljs-built_in">str</span> = <span class="hljs-string">'|psi&gt; = '</span><br>    <span class="hljs-keyword">for</span> i, seq <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seqs):<br>        <span class="hljs-built_in">str</span> += <span class="hljs-string">'{}|{}&gt;'</span>.<span class="hljs-built_in">format</span>(coef[i], seq)<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-built_in">len</span>(seqs) - <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">str</span> += <span class="hljs-string">'+'</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></tbody></table></figure><p></p><p>测试一下，生成一个大名鼎鼎的 <code>bell</code> 纠缠态 $\mathinner{|\varphi\rangle} = \frac{1}{\sqrt{2}}\mathinner{|00\rangle} + \frac{1}{\sqrt{2}}\mathinner{|11\rangle}$：<br></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wf</span> = a<span class="hljs-number">2</span>wf(np.matrix([np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)]), <span class="hljs-number">2</span>)<br><span class="hljs-attribute">print_wf</span>(wf)<br></code></pre></td></tr></tbody></table></figure><p></p><p>打印：<br><code>|psi&gt; = 0.7071067811865476|00&gt;+0.7071067811865476|11&gt;</code></p><p>现在看起来就直观多了~</p><h2 id="量子门"><a href="#量子门" class="headerlink" title="量子门"></a>量子门</h2><p>量子计算机仅仅只有量子比特是不够的，为了实现量子算法，还需要对量子比特进行酉变换，这种变换我们使用量子门实现。</p><p>量子比特可以看做是布洛赫球上的一个向量：<br><img src="/img/qc-3-1.png" alt=""><br>量子门对应的就是该向量的旋转，要注意的一点是为了满足归一性，量子门必须是酉矩阵。</p><p>量子门分为单比特量子门和多比特量子门，对于单比特量子门，常用的有泡利矩阵：</p><script type="math/tex; mode=display">\sigma_x=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix}，\sigma_y=\begin{pmatrix}0 & -i\\ i & 0\\\end{pmatrix}，\sigma_z=\begin{pmatrix}1 & 0\\ 0 & -1\\\end{pmatrix}</script><p>代码实现：<br></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">X = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br>Y = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>j], [<span class="hljs-number">1</span>j, <span class="hljs-number">0</span>]])<br>Z = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>]])<br></code></pre></td></tr></tbody></table></figure><br>Hadamard门：<br><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">H = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)], [<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>), -<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)]])<br></code></pre></td></tr></tbody></table></figure><br>T门：<br><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">T = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, np.exp(<span class="hljs-number">1</span>j * np.pi / <span class="hljs-number">4</span>)]])<br></code></pre></td></tr></tbody></table></figure><br>V门：<br><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">V = np.<span class="hljs-built_in">array</span>([[(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>j * (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>], [<span class="hljs-number">-1</span>j * (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>, (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>]])<br></code></pre></td></tr></tbody></table></figure><br>我们将 <code>X</code> 门施加到一个基态为<code>0</code>的量子比特上：<br><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">amplitudes = basis(<span class="hljs-string">'0'</span>).A1<br>wf = np.dot(amplitudes, X)<br><span class="hljs-function"><span class="hljs-title">print_wf</span><span class="hljs-params">(a2wf(wf, <span class="hljs-number">1</span>)</span></span>)<br></code></pre></td></tr></tbody></table></figure><br>打印：<br><code>|psi&gt; = 1|1&gt;</code>  <p></p><p>完全符合预期。</p><p><strong>下面构造双量子门。</strong></p><p>已经被证明，所有多量子门都可以用双量子门和单量子门生成，因此我们只需要构造双量子门即可。</p><p>一般的双量子门有两种情况：</p><ol><li>控制位在上</li><li>控制位在下</li></ol><p>第一种情况很常见，如：</p><script type="math/tex; mode=display">CNOT=\begin{pmatrix}1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\0 & 0 & 1 & 0\\\end{pmatrix}</script><p>对于第二种情况，只需要将内部交换顺序，使用<code>CNOT_DOWN</code>表示控制位在下：</p><script type="math/tex; mode=display">CNOT\_DOWN=\begin{pmatrix}0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1\\\end{pmatrix}</script><p>同时，控制位和作用位不一定是紧挨着，它们之间可能存在<em>跨线</em>，这种情况稍微复杂一点。</p><p>还是拿<code>CNOT</code>门来举例，对于<strong>跨一条线且控制位在上</strong>的控制非门，我们定义为<code>CNOT3_02</code>，它的矩阵形式：</p><script type="math/tex; mode=display">CNOT3\_02=\begin{pmatrix}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\end{pmatrix}</script><p>可以看到，矩阵左上角是不变的，右下角重复<code>X</code>门</p><p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：<br></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">base = np.identity(m_size)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">4</span>)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>            base[<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">2</span> + i * <span class="hljs-number">2</span> + j)][<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">2</span> + i * <span class="hljs-number">2</span> + k)] = GateManager.Gates[gate][j][k]<br></code></pre></td></tr></tbody></table></figure><p></p><p>对于<strong>跨一条线且控制位在下</strong>的控制非门，会更麻烦一点，<br>我们定义为<code>CNOT3_20</code>，它的矩阵形式：</p><script type="math/tex; mode=display">CNOT3\_20=\begin{pmatrix}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\end{pmatrix}</script><p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">base = np.identity(m_size)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">4</span>)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>            base[<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * i + j * m_size / <span class="hljs-number">2</span>)][<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * i + k * m_size / <span class="hljs-number">2</span>)] = GateManager.Gates[gate][j][k]<br></code></pre></td></tr></tbody></table></figure><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>一个量子系统是一个黑盒，在测试之前我们永远不知道它会塌缩到什么状态，而一个黑盒对我们来说是没有意义的。因此，从黑盒中提取出有用信息的过程就是测量了。</p><p>测量会将量子比特塌缩为经典比特，而该量子比特的振幅就是塌缩成0或1的概率。举个例子，对于一个量子状态</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=\begin{pmatrix}{}\frac{1}{\sqrt{3}}\\\frac{1}{\sqrt{3}}\\\frac{i}{\sqrt{3}}\\\end{pmatrix}</script><p>概率是以投影的形式给出的，而投影到<code>|0&gt;</code>状态的是算子为：</p><script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=\left(\begin{array}{c}1\\0\\0\\\end{array}\right)\left(\begin{array}{c}1 & 0 & 0\\\end{array}\right)</script><p>同时，</p><script type="math/tex; mode=display">\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=\begin{pmatrix}\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\\end{pmatrix}</script><p>因此我们可以计算出内积</p><script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p><p>已知了原理部分，就可以进行编码了。我们的量子计算机有两种测量方式，分别是进行全局测量和对单个比特进行测量，全局测量就是对所有比特同时进行测量：<br></p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def measureAll():<br>    probabilities = []<br>    <span class="hljs-keyword">for</span> amp <span class="hljs-keyword">in</span> <span class="hljs-built_in">np</span>.nditer(amplitudes):<br>        probability = <span class="hljs-built_in">np</span>.absolute(amp)**<span class="hljs-number">2</span><br>        probabilities.<span class="hljs-built_in">append</span>(probability)<br>    results = list(<span class="hljs-built_in">range</span>(len(probabilities)))<br>    value = <span class="hljs-built_in">np</span>.binary_repr(<br>        <span class="hljs-built_in">np</span>.<span class="hljs-built_in">random</span>.choice(results, p=probabilities),<br>        numQubits<br>    )<br>    <span class="hljs-built_in">return</span> value<br></code></pre></td></tr></tbody></table></figure><br>我们也可以对单个比特进行测量：<br><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl">def measureOne(place):<br>    prob_<span class="hljs-number">0</span> = <span class="hljs-number">0</span><br>    probabilities = np.zeros(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i, seq in enumerate(seqs):<br>        prob_<span class="hljs-number">0</span> += np.square(coef[i]) <span class="hljs-keyword">if</span> se<span class="hljs-string">q[index]</span> == <span class="hljs-string">'0'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    probabilities[<span class="hljs-number">0</span>] = prob_<span class="hljs-number">0</span><br>    probabilities[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> - prob_<span class="hljs-number">0</span><br>    ls = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>    selected = np.random.choice(ls, p=probabilities)<br>    measured[place] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 重新生成状态</span><br>    co = []<br>    ba = []<br>    <span class="hljs-keyword">for</span> i, seq in enumerate(seqs):<br>        <span class="hljs-keyword">if</span> se<span class="hljs-string">q[index]</span> == str(selected):<br>            co.append(coef[i])<br>            ba.append(se<span class="hljs-string">q[0:index]</span> + se<span class="hljs-string">q[index+1:len(seq)]</span>)<br>    co = normalization(co)<br>    amplitudes = wave_func(co, ba).A1<br>    numQubits = len(ba[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> selected<br></code></pre></td></tr></tbody></table></figure><br>不同的是，在进行单个比特的测量后，需要重新生成状态。<p></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如此一来，我们就实现了一个量子计算机，麻雀虽小五脏俱全，绝大部分量子算法都可以用这个玩具实现了~</p><p>总结一下，我们用到了哪些知识：</p><ul><li>线性代数</li><li>量子力学基础</li><li>Python</li></ul><p>未来可以给这个量子计算机加上其他的功能，比如 <em>量子排列优化</em>、<em>量子线路分解</em>、<em>量子并行模拟</em> 等等，总之接下来就是搭积木了</p><blockquote><p>Reference<br>[1] <a href="https://github.com/adamisntdead/QuSimPy">https://github.com/adamisntdead/QuSimPy</a><br>[2] <a href="https://github.com/corbett/QuantumComputing">https://github.com/corbett/QuantumComputing</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/267302584">https://zhuanlan.zhihu.com/p/267302584</a><br>[4] <a href="https://qiskit.org/">qiskit文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 量子计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从奥术神座到数理学史</title>
      <link href="2020/11/13/phy-history/"/>
      <url>2020/11/13/phy-history/</url>
      
        <content type="html"><![CDATA[<p>说实话【奥术神座】这本书一直在我的书架上吃灰，直到看完诡秘之主，在强烈的书荒感下，我才捡起了乌贼娘的这本成神之作。</p><p>虽然是一本老书了，但是看了之后才意识到这果然是一本仙草，给我的惊喜感甚至超过了诡秘之主。就像是戳中了作为理科生的内心深处，我对这种“研究万物研究神”的小说没有丝毫抵抗力，幸好没有错过啊~</p><p>根据书中的设定，人的实力会随着认识世界的深刻程度而增强，换句话说就是“知识就是力量（物理版）”。</p><p>在一般的网络小说里，虽然力量等级的划分十分清晰，却很少会有作品去讨论“力量”的来源是什么。大家理所当然地拿来用，而几乎没有考虑过为什么会有魔法会有斗气。而奥术神座将神灵以及魔法纳入到物理体系中来，魔法就是科学，魔法是用来研究的对象，而创造魔法的过程就是人类研究大自然的过程。</p><p>曾经在知乎上看到过这么一个问题：“如果世界上真的有鬼，那么唯物主义者还会坚持他们的信仰吗？”</p><p>如果世界上真的有鬼，那么搞科研的才是最兴奋的吧——因为又可以在新的领域水paper了（笑）。只要是可观测的，那么鬼本身就是值得被研究的对象，说不定“鬼”本身会被称为一种特殊的“场”，同属物质世界的一部分。</p><p>在小说开头部分，路西恩的音乐家章节对应着文艺复兴的历史。从赞美神的宗教交响乐，再到以人为主题的流行乐，小说和现实交相辉映，让人读着不觉烦闷。不得不说，作者渲染气氛的功力实属老道，不管是对音乐会的描写，还是主人公拿出一个个经典乐曲的小高潮，从文字中都透出了音乐的美感。我想看了原文又去听音乐的应该不在少数，至少我是第一次把莫扎特的月光听完 :)</p><p>在书中后半部分，极为精彩的是其对数理学史的演绎。从波粒战争（异世界版）到量子力学的争议，书中的大奥术师基本都能在现实中找到原型。诸如：</p><p>道格拉斯——牛顿，爱因斯坦</p><p>费尔南多——泡利</p><p>奥利弗——薛定谔</p><p>布鲁克——麦克斯韦</p><p>迪耶普——德布罗意</p><p>列夫斯基——罗巴切夫斯基</p><p>他们争论的过程对应着物理学史的经典桥段，就像爱因斯坦对波尔怒吼：上帝不会掷骰子！</p><p>遗憾的是小说并没有涉及计算机科学的发展史，这也算是我的一点小私心了…</p><p>全文令我印象最深，也是让我为之颤抖的一段文字出自路西恩为了帮助列夫斯基（原型是罗巴切夫斯基，罗氏几何提出者）舌战群儒的片段，原文我贴在了附录中。非欧几何难以理解，但它却是广义相对论的数学基础，尽管当初提出它时人们并不知道它有什么作用。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p>以下出自小说原文</p></blockquote><p>路西恩整理了下领口，拿着一叠文件走上讲台，步伐稳健，不慌不忙。</p><p>“伊文斯委员，如果我是你，就不会再坚持，我很理解你对颠覆性成果的热爱，但这依然要尊重基本的现实。”涅西卡突然开口说道，如果路西恩的老师不是风暴主宰，他绝不会如此客气。</p><p>路西恩微笑看向他：“我只尊重真实。”</p><p>无论表情还是语气，委员们都能看出来他口中的真实是指列夫斯基的论文，于是米里娜轻轻笑了一声，却不带丝毫笑意，冰冷冷如同北地深处的寒风：“伊文斯委员，我想你不知道，如果一位审核委员在审核论文时犯下了明显的、故意的、没有理由的错误，他将被取消委员资格。”</p><p>“这句话也是我想对各位说的。”路西恩站到了讲台上，笑容平淡，话语却绝不柔和。</p><p>轰，仿佛有什么在内心炸响，一位位数理领域的委员都充满了愤怒，这是在指责和攻击我们？</p><p>费尔南多眨了眨眼睛，有点疑惑自己一向优雅有礼貌的学生竟然会说出这么带有挑衅意味的话语，他心里暗道，有点反常啊，看来有的人遇到麻烦了……</p><p>“伊文斯委员，你还是先想想怎么将想象中的几何变到现实中吧。”另外一位女性委员玛佩尔嘲讽道，她容貌平凡，古板严肃，带着灰顶尖帽，如同教会的老修女。</p><p>黑色头发凌乱，似乎不太喜欢打理自己的中年男士萨尔盖罗左手拇指和食指捏住脸庞，声音低沉地道：“我很想知道伊文斯委员你为什么将列夫斯基的论文称为几何领域的微积分革命，你有什么理由？你能证明他的正确吗？”</p><p>“你在数理领域没有什么成果，我严重怀疑你审核这篇论文的能力。”最先说话的涅西卡直接质疑起路西恩的数理水准。</p><p>被路西恩的话语激怒，一位位委员都变成了好斗的公鸡。</p><p>路西恩举手压了压，声音响亮：“对于我数理水准的质疑，请在我讲解完之后再向委员会提出。”</p><p>接着他略带咆哮地道：“从现在开始，论文以外的一切统统消失，你们是审核委员，不是小孩子！”</p><p>被这突如其来的咆哮震住，会议室一下变得安静。</p><p>路西恩环视会议室一圈，对列夫斯基微微点头，接着高声道：“我讲述理由时，不允许提问，不允许打断，所有的问题都等到讲述完一起提出，不过，我讲述时，会向各位提问，请各位诚实地回答，对得起胸口的委员徽章和头顶的星空！”</p><p>委员们沉默了，一时找不到反驳路西恩的理由，作为一名审核委员，作为三次霍尔姆皇冠奖、一次不朽王座奖得主，他有资格提出一定的合理要求，而且他的气势就像蓄势待发的暴风雨，择人而噬，让人下意识不想在小问题上激怒他。</p><p>“既然大家没有反对，那就算同意。”路西恩看向老师风暴主宰。</p><p>费尔南多板着脸道：“接下来就按照伊文斯委员说的做。”</p><p>于是路西恩转过身，操纵魔法阵，让投影上只显示最初的公理和公设：</p><p>“涅西卡委员，我问你，这几个公理和公设有错吗？”</p><p>涅西卡条件反射式回答：“这与真实世界不同。”</p><p>“涅西卡委员，忘记外面的阳光，忘记外面的世界，忘记这篇论文后面的内容，你诚实地回答，这几个公理和公设有错误吗？”路西恩厉声喝道。</p><p>涅西卡被路西恩的气势压住，仔细看了看，这不就是高塔几何的五个公理、四个公设，以及列夫斯基提出的假设吗，于是点头回答：“前面的公理和公设没有错误，但最后一个是荒谬的。”</p><p>“这是反证法，你不知道反证法吗？”路西恩再次喝道。</p><p>白色眉毛抖动了一下，涅西卡没办法让自己像个愚昧的白痴，没学过数学的傻瓜：“那没有问题。”</p><p>“你们认为有错误吗？有就勇敢站起来！”路西恩就像在魔法学校上课，面对一位位魔法学徒，气势逼人。</p><p>这怎么可能有错误，其他委员摇了摇头。</p><p>于是路西恩再次投影出几行内容，果然是列夫斯基的论文。</p><p>“米里娜委员，你认为这一段推理有前提和逻辑上的错误吗？”路西恩严厉地目光看向米里娜。</p><p>米里娜起身冷笑：“这与现实不同，找不到……”</p><p>“忘记它们！我说了忘记它们！只考虑前提假设和逻辑演绎，只考虑纯粹的数学问题！”路西恩咆哮着打断了米里娜的话，“告诉我，这一段推理有逻辑上的错误吗？”</p><p>米里娜被咆哮弄得不知该怎么反驳，仔细推导了一遍，摇了摇头道：“没有逻辑上的错误和漏洞，没有将其他等价命题当做条件使用。”</p><p>“很好。”路西恩示意她坐下，接着再次投影出几行，“玛佩尔委员，你认为这一段推理有前提和逻辑上的错误吗？”</p><p>就这样，路西恩一段段地询问，一次次的咆哮，一遍遍地让委员们忘记别的因素，只考虑单纯的公理公设和逻辑演绎问题。</p><p>受着咆哮，听着问题，回答着有没有错误，涅西卡等委员的脸色渐渐开始发青，额头似乎有一点点冷汗泌出，列夫斯基则精神焕发，仿佛路西恩的每一声咆哮，委员们的每一次回答，都在给他注入信心，带来喜悦，而费尔南多则若有所思地点了点头。</p><p>随着论文的最后几行投影出来，路西恩的目光转向涅西卡，声音低沉地道：“涅西卡委员，这一段有没有逻辑演绎的漏洞，有没有前提假设的错误。”</p><p>涅西卡双手紧握，依稀能感觉到掌心的潮湿，他吞咽了一口唾沫，没敢再提现实，略微颤抖地道：“没有漏洞，没有错误。”</p><p>“很好，没有漏洞，没有错误。”路西恩看着六位委员，似乎在自言自语。</p><p>突然，他用最大的声音咆哮起来，仿佛狂风暴雨降临：</p><p>“既然每一处地方都没有错误，那你们告诉我这篇论文究竟错在哪里？！”</p><p>“告诉我，它究竟错在哪里？！”</p><p>米里娜被吓了一跳，下意识回答：“与我们的直观认识和现实经验违……”</p><p>“将它们抛出你的脑子！”路西恩咆哮着打断，“告诉我，从纯粹的数学上讲，从前提假设和逻辑演绎上讲，它究竟错在哪里？”</p><p>“错在哪里？”</p><p>涅西卡、米里娜等人沉默了，不知该怎么回答，不提现实，不提经验认识，确实找不到前提和逻辑上的错误。</p><p>列夫斯基两只手紧紧握起，脑袋微抬，闭上了双眼，满脸的复杂情绪，有喜有悲，有痛苦有希望。</p><p>“路西恩·伊文斯的咆哮真有风暴主宰的气势，不愧是他的学生。”</p><p>“又一个风暴主宰吗？”</p><p>不知为什么，米里娜等人的脑袋里不是思考反驳的话语，而是突然冒出了这些想法。</p><p>费尔南多摇了摇头，好笑地自语：“我可没有私生子啊。”</p><p>路西恩见自己的气势让他们一时组织不起反击，于是乘胜追击，将手中的另外一份论文放入魔法阵中，然后调整魔法阵，将它与列夫斯基的论文共同展示。</p><p>“《非高塔几何解释的尝试》……”米里娜看到了论文的题目，接着阅读了下去。</p><p>论文一页页展示，但不是替换前面的内容，而是环绕会议室，一张张并列地显示。</p><p>涅西卡揉了揉自己眉头，疑惑地道：“用的微分几何知识……”</p><p>玛佩尔、萨尔盖罗等委员也跟着读了起来，读着读着，他们的脸色就变得煞白，一滴滴冷汗从额头滑落，双手差点拿不稳羽毛笔。</p><p>“这是……”列夫斯基跳了起来，仿佛看到魔法女神出现在了自己面前。这是自己新几何学的模型！这是超过了正常想象与直观认识的“双曲面”模型！这是最有力的证明！</p><p>他无声地痛哭着，真真实实地看到了太阳的升起，黑暗的消退，希望的降临。</p><p>突然，又是一篇论文出现，相当简单，用投影的概念，在单位圆上证明了列夫斯基几何与高塔几何的相容，如果高塔几何成立，那列夫斯基几何也成立！</p><p>简洁的推导，美妙的证明，充满了数学的美感，再也没有比它更震撼涅西卡等委员的证据了！</p><p>我没有错，我一直走在正确的道路上！列夫斯基心里疯狂呐喊起来。</p><p>这时，路西恩的声音柔和地在他们耳边响起：“众所周知，我们只能看到一定频率范围内的光，超过了这个范围，我们就无法直接感受到，只能依靠别的工具来判断，而别的工具同样有着极限。”</p><p>由于论文需要的前置数理成果有些没出来，路西恩是自行推导自行给出，比原本的论文复杂了一些，但这不妨碍米里娜等委员看懂，他们一边看，一边听到路西恩的话语，心中油然升起强烈的疑惑，他现在说这个做什么？</p><p>“所以，在特殊布置的光线场景中，我们的眼睛会由于自身的局限被欺骗，从而产生幻觉，这就是部分幻术的原理。”</p><p>虽然疑惑，但涅西卡、列夫斯基等人都点了点头，说得没错。</p><p>路西恩继续声音柔和地说道：“同样的，我们的耳朵也是一样，超过一定范围的音波就无法听到，一定条件下，它会被干扰，会产生幻听。”</p><p>“我们的认识，我们的经验，受限于我们身体和灵魂的构造，会有相当程度的局限性，相信大家都会变形术，变形成不同种类生物后感受到的世界与我们现在感受到的世界相同吗？”</p><p>“不同。”列夫斯基肯定地回答，虽然很多变形术都依赖于生理解剖上的了解，像在知道蝙蝠靠超声波探路而不是眼睛之前，变形成的蝙蝠都有这方面的偏误，但从原始的魔法花纹得到的变形术，依然能让魔法师们部分了解到不同生物感受的世界。</p><p>路西恩微笑起来，看着迷茫的米里娜等人：“那是我们正确，还是它们正确？很显然，这是从不同角度看待同一件事情，大家都正确，都属于事情真实的一部分，因此，我们的经验，我们的认识是有局限的。”</p><p>“而我们的想象力是建立在我们的经验之上，有局限的经验就束缚着我们的想象力，让它不是万能的。探索世界越深入，我们就会发现很多事情我们完全想象不出来，完全违背了我们的直观认识。”</p><p>费尔南多严肃地点了点头，大概明白了路西恩的意思。</p><p>涅西卡、米里娜、列夫斯基等人则还有点迷茫，直直地看着路西恩。</p><p>路西恩抬起右手，表情变得严肃：</p><p>“所以，你的眼睛会欺骗你，你的耳朵会欺骗你，你的经验会欺骗你，你的想象力同样会欺骗你。”</p><p>说到这里，他停顿了一下，在众人的目光里将右手指向投影在墙面的论文，指向那逻辑严密的演绎和结论，低声道：</p><p>“但数学不会。”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light|来设计一款编程语言吧(2)：语法分析</title>
      <link href="2020/11/11/light-2/"/>
      <url>2020/11/11/light-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>上一篇blog介绍了Light语言的词法分析程序，生成的Token串就是语法分析的输入。这篇文章将对Light使用的语法分析器进行一个总结</p><p>语法分析器的目的是将Token串生成抽象语法树(AST)，通过抽象语法树可以很容易的生成目标代码，或者进行代码优化等操作</p><p>任何语言都有其语法，Light的语法遵循LL(1)文法设计，下面介绍基本原理与实现</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><h3 id="1-1-LL-1-文法"><a href="#1-1-LL-1-文法" class="headerlink" title="1.1 LL(1)文法"></a>1.1 LL(1)文法</h3><p>LL(1)文法主要目的是为了解决两个痛点问题：</p><ul><li>回溯问题  </li></ul><p>这是一个非终结符具有多个产生式候选带来的问题</p><p>当一个非终结符用某个候选式进行匹配时，匹配成功可能是暂时的</p><p>如果要遍历所有匹配的可能，在每个多候选式终结符进行匹配时，就要记录下当前等待匹配的符号的位置、当前推导句型中非终结符的位置，和该非终结符选择的产生式的序号</p><p>某次匹配失败后，舍弃某些分析结果，回溯到上一个岔路口，走下一条路尝试</p><p>这会导致语法分析的效率问题，此外，最终分析失败时，没法确定应该在哪个岔路口抛出错误</p><ul><li>左递归问题  </li></ul><p>对于类似 x*y 的文法</p><p><img src="https://img-blog.csdnimg.cn/20190803122821496.png" alt=""></p><p>若定义<code>S → xAy  A → A* | *</code>，那么在进行语法分析时很容易产生左递归：</p><p><img src="https://img-blog.csdnimg.cn/20190803123038201.png" alt=""></p><p>在这种情况下，通过将文法转化成LL(1)文法，可以消除上面的两种现象</p><p>这时需要引入First集与Follow集的概念，这里不再赘述。总的来说，LL(1)文法的限制条件为：</p><p>1) 文法不含左递归</p><p>2) 文法中每一个非终结符 A 的各个产生式的候选首符集不相交，即若 A → α1 | α2 | … | αn<br>FIRST(αi)∩FIRST(αj) = ∅，i ≠ j</p><p>3) 对于文法中的每个非终结符 A，若它的某个候选首符集包含 ε，则 FIRST(αi)∩FOLLOW(A) = ∅</p><p>Light语言的部分文法如下所示：<br></p><figure class="highlight xl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">INT := [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+<br>Array := [a-zA-Z]*\[INT\]<br>Identifier := [_a-zA-Z]+[_a-zA-Z0-<span class="hljs-number">9</span>]*<br>Compare := &gt;|&lt;|==|&gt;=|&lt;=<br><br>A<span class="hljs-function"><span class="hljs-title">rgument</span>    ---------&gt;</span> Identifier | Array<br>F<span class="hljs-function"><span class="hljs-title">actor</span>      ---------&gt;</span> INT<br>E<span class="hljs-function"><span class="hljs-title">xpression</span>  ---------&gt;</span> Factor [+|-|*|/|Compare Expression]<br>B<span class="hljs-function"><span class="hljs-title">ool</span>        ---------&gt;</span> [!] Identifier|Expression<br>IFS<span class="hljs-function"><span class="hljs-title">tatement</span> ---------&gt;</span> <span class="hljs-keyword">if</span>(Bool) { ; Statement}<br>W<span class="hljs-function"><span class="hljs-title">hileStatement</span> ------&gt;</span> <span class="hljs-keyword">while</span>(Bool) { ; Statement}<br>F<span class="hljs-function"><span class="hljs-title">uncStatement</span> -------&gt;</span> func Identifier() { ; Statement}<br>R<span class="hljs-function"><span class="hljs-title">eturn</span>      ---------&gt;</span> return INT|Identifier<br>S<span class="hljs-function"><span class="hljs-title">tatement</span>   ---------&gt;</span> IFStatement | WhileStatement | FuncStatement<br>D<span class="hljs-function"><span class="hljs-title">eclare</span>     ---------&gt;</span> Identifier = FuncStatement|INT<br>P<span class="hljs-function"><span class="hljs-title">rogram</span>     ---------&gt;</span> Declare { ; Statement}<br>F<span class="hljs-function"><span class="hljs-title">uncCall</span>    ---------&gt;</span> Identifier([INT]*)<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="1-2-自上向下的文法分析"><a href="#1-2-自上向下的文法分析" class="headerlink" title="1.2 自上向下的文法分析"></a>1.2 自上向下的文法分析</h3><p>文法分析可以分为自上向下和自下向上，对于Light语言我们采用自上向下的分析方式，同时自上向下的分析主要有递归下降分析和构造LR语法分析表的方法</p><p>在实现文法分析上，我们采用递归下降分析法。<del>主要是为了方便写代码</del></p><p>递归下降分析法被很多编译器采用，如GCC 4.0，LLVM，…</p><p>算法的基本思想是</p><ul><li>每个非终结符构造一个分析函数</li><li>用向前看符号指导产生式规则的规则</li></ul><p>实现方面举个例子，对于一般的语法<br></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">X -&gt; β<span class="hljs-number">11</span> ... β<span class="hljs-number">1</span>i<br>   | β<span class="hljs-number">21</span> ... β<span class="hljs-number">2</span>j<br>   | β<span class="hljs-number">31</span> ... β<span class="hljs-number">3</span>k<br>   | ...<br></code></pre></td></tr></tbody></table></figure><br>我们写出它的递归下降分析程序：<br><figure class="highlight lasso"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">parse_X():<br>    token = nextToken()<br>    switch(token)<br>        <span class="hljs-keyword">case</span> <span class="hljs-params">...</span>:  <span class="hljs-comment">// β11 ... β1i</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-params">...</span>:  <span class="hljs-comment">// β21 ... β2j</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-params">...</span>:  <span class="hljs-comment">// β31 ... β3k</span><br>        <span class="hljs-params">...</span><br>        default: error(<span class="hljs-string">"..."</span>)<br></code></pre></td></tr></tbody></table></figure><p></p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>作为输出对象，首先进行抽象语法树(AST)的构造</p><p>AST可以参考二叉树，与二叉树不同的是，AST可以不只有一个子节点，同时AST的根节点都是非终结符，叶节点都是终结符</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyntaxTree</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.root = <span class="hljs-literal">None</span><br>        self.current = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_child_node</span>(<span class="hljs-params">self, new_node, father=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">pass</span><br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyntaxTreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value=<span class="hljs-literal">None</span>, _type=<span class="hljs-literal">None</span></span>):</span><br>        self.value = value<br>        self.<span class="hljs-built_in">type</span> = _type<br>        self.father = <span class="hljs-literal">None</span><br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br>        self.first_son = <span class="hljs-literal">None</span><br></code></pre></td></tr></tbody></table></figure><p>接下来构造<code>match</code>函数，该函数匹配一个token并将指针向后移一位<br></p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, token)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.lookahead[<span class="hljs-number">0</span>] == token[<span class="hljs-number">0</span>]<span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.lookahead = <span class="hljs-keyword">self</span>.getNextToken()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNextToken</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">self</span>.current_token += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.current_token &gt;= len(<span class="hljs-keyword">self</span>.TOKEN)<span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.EOF<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.TOKEN[<span class="hljs-keyword">self</span>.current_token]<br></code></pre></td></tr></tbody></table></figure><p></p><p>下面给出递归下降分析法的实例，例如对算数表达式进行分析</p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">parse_E</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">parse_T</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">match</span>(<span class="hljs-variable">token</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-variable">token</span> == +)</span><br>        <span class="hljs-function"><span class="hljs-title">parse_T</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">match</span>(<span class="hljs-variable">token</span>)</span><br><br><span class="hljs-function"><span class="hljs-title">parse_T</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">parse_F</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">match</span>(<span class="hljs-variable">token</span>)  </span><br><span class="hljs-function">    <span class="hljs-title">while</span>(<span class="hljs-variable">token</span> == *)</span><br>        <span class="hljs-function"><span class="hljs-title">parse_F</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">match</span>(<span class="hljs-variable">token</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>其他语法的分析也是同样的道理，需要对每一个非终结符都编写一个分析函数，根据输入的Token的类型执行相应的分析函数</p><p>最后执行该语法分析器，生成的语法树如下所示：<br></p><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 源代码</span><br>func add(a, b){<br>    <span class="hljs-keyword">return</span> a+b<br>}<br>three = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// dfs打印语法树</span><br>( <span class="hljs-attr">self:</span> Program None,<span class="hljs-attr">first_son:</span> FuncStatement, <span class="hljs-attr">father:</span> None, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> FuncStatement None,<span class="hljs-attr">first_son:</span> add, <span class="hljs-attr">father:</span> Program, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> Declare_func )<br><br>( <span class="hljs-attr">self:</span> add FuncStatement_Name,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> FuncStatement, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> ParameterList )<br><br>( <span class="hljs-attr">self:</span> ParameterList None,<span class="hljs-attr">first_son:</span> a, <span class="hljs-attr">father:</span> FuncStatement, <span class="hljs-attr">left:</span> add, <span class="hljs-attr">right:</span> Statement )<br><br>( <span class="hljs-attr">self:</span> a <span class="hljs-number">500</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> ParameterList, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> b )<br><br>( <span class="hljs-attr">self:</span> b <span class="hljs-number">500</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> ParameterList, <span class="hljs-attr">left:</span> a, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> Statement None,<span class="hljs-attr">first_son:</span> Return, <span class="hljs-attr">father:</span> FuncStatement, <span class="hljs-attr">left:</span> ParameterList, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> Return None,<span class="hljs-attr">first_son:</span> Expression, <span class="hljs-attr">father:</span> Statement, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> Expression None,<span class="hljs-attr">first_son:</span> a, <span class="hljs-attr">father:</span> Return, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> a <span class="hljs-number">500</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> Expression, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> + )<br><br>( <span class="hljs-attr">self:</span> + <span class="hljs-number">400</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> Expression, <span class="hljs-attr">left:</span> a, <span class="hljs-attr">right:</span> b )<br><br>( <span class="hljs-attr">self:</span> b <span class="hljs-number">500</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> Expression, <span class="hljs-attr">left:</span> +, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> Declare_func None,<span class="hljs-attr">first_son:</span> three, <span class="hljs-attr">father:</span> Program, <span class="hljs-attr">left:</span> FuncStatement, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> three <span class="hljs-number">500</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> Declare_func, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> = )<br><br>( <span class="hljs-attr">self:</span> = <span class="hljs-number">406</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> Declare_func, <span class="hljs-attr">left:</span> three, <span class="hljs-attr">right:</span> FuncCall )<br><br>( <span class="hljs-attr">self:</span> FuncCall None,<span class="hljs-attr">first_son:</span> add, <span class="hljs-attr">father:</span> Declare_func, <span class="hljs-attr">left:</span> =, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> add FuncCall_Name,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> FuncCall, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> ParameterList )<br><br>( <span class="hljs-attr">self:</span> ParameterList None,<span class="hljs-attr">first_son:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">father:</span> FuncCall, <span class="hljs-attr">left:</span> add, <span class="hljs-attr">right:</span> None )<br><br>( <span class="hljs-attr">self:</span> <span class="hljs-number">1</span> <span class="hljs-number">600</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> ParameterList, <span class="hljs-attr">left:</span> None, <span class="hljs-attr">right:</span> <span class="hljs-number">2</span> )<br><br>( <span class="hljs-attr">self:</span> <span class="hljs-number">2</span> <span class="hljs-number">600</span>,<span class="hljs-attr">first_son:</span> None, <span class="hljs-attr">father:</span> ParameterList, <span class="hljs-attr">left:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">right:</span> None )<br></code></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light|来设计一款编程语言吧(1)：词法分析</title>
      <link href="2020/11/10/light-1/"/>
      <url>2020/11/10/light-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该系列对Light语言进行一个总结性质的记录，emm勉强算官方文档吧<span class="github-emoji"><span>😝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Light是一款跨平台轻量级的解释型语言，语法借鉴JavaScript，支持条件语句、循环语句，目前变量支持整数类型、函数类型</p><p>完整项目见我的GitHub</p><p>该语言使用实例如下所示：<br></p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">#############################################<br>#                 Quick start               #<br>#############################################<br>func add(a, b){<br>    return a+b<br>}<br>three = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>print(three)<br></code></pre></td></tr></tbody></table></figure><p></p><p>具体语法规则放在第二篇blog中介绍，下面开始进行词法分析</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>词法分析处于编译原理的第一环节，目的是将源文件转化成可供语法分析的Token串。在该过程中，需要将变量、数字、关键词、分隔符等都识别出来，并制备成Token格式</p><p>先了解一下词法分析的知识关系图</p><p><img src="https://img-blog.csdnimg.cn/20190112203946406.png" alt=""></p><p>开发一个词法分析器是在词法定义的基础上的，词法定义需要使用正则表达式</p><p>正则表达式可以转换为NFA（Non-determinate finite automata 不确定的有穷自动机），NFA可以转换为DFA（determinate finite automata 确定有穷自动机），DFA可以极小化，进而使用为开发词法分析器的工具</p><p>词法分析器有两种识别方法，分别是关联和独立两种形式，这里我们使用独立的形式，即把词法分析当做是一个独立的整体，并将处理好的结果交给下一步来执行。</p><h3 id="1-1-Token"><a href="#1-1-Token" class="headerlink" title="1.1 Token"></a>1.1 Token</h3><p>定义Token如下：</p><div class="table-container"><table><thead><tr><th>KEYWORD</th><th>tokenID</th><th>SEPARATOR</th><th>tokenID</th><th>OPERATOR</th><th>tokenID</th></tr></thead><tbody><tr><td>if</td><td>100</td><td>(</td><td>300</td><td>+</td><td>400</td></tr><tr><td>elif</td><td>101</td><td>)</td><td>301</td><td>-</td><td>401</td></tr><tr><td>else</td><td>102</td><td>[</td><td>302</td><td>*</td><td>402</td></tr><tr><td>while</td><td>103</td><td>]</td><td>303</td><td>/</td><td>403</td></tr><tr><td>break</td><td>104</td><td>{</td><td>304</td><td>&gt;</td><td>404</td></tr><tr><td>func</td><td>105</td><td>}</td><td>305</td><td>&lt;</td><td>405</td></tr><tr><td>return</td><td>106</td><td>:</td><td>306</td><td>=</td><td>406</td></tr><tr><td>———</td><td>———</td><td>;</td><td>307</td><td>&gt;=</td><td>407</td></tr><tr><td>IDENTIFY</td><td>500</td><td>\n</td><td>308</td><td>&lt;=</td><td>408</td></tr><tr><td>INT</td><td>600</td><td></td><td></td><td>==</td><td>409</td></tr></tbody></table></div><p>下面就不一一列举了…</p><p>一个词法单元(Token)由两部分组成，分别是(id, content)，其中</p><ul><li>关键词(KEYWORD)<br>是具有特殊意义的词，不能被其他方式使用</li><li>分隔符(SEPARATOR)<br>分隔语句，产生语义</li><li>操作符(OPERATOR)<br>进行运算与比较</li><li>变量(IDENTIFY)<br>变量可以是函数，也可以是数</li><li>整数类型(INT)<br>定义整数类型</li></ul><h3 id="1-2-DFA"><a href="#1-2-DFA" class="headerlink" title="1.2 DFA"></a>1.2 DFA</h3><p>DFA是确定有穷自动机，使用DFA来生成我们需要的符号，比如生成一个无符号实数的DFA：</p><p><img src="https://img-blog.csdnimg.cn/20190113124130830.png" alt=""></p><p>对于DFA，我们往往需要把它化成最简，然后就可以直接用代码实现了</p><h3 id="1-3-NFA"><a href="#1-3-NFA" class="headerlink" title="1.3 NFA"></a>1.3 NFA</h3><p>词法分析的一般过程是 regular =&gt; NFA =&gt; DFA =&gt; code</p><p>NFA是对正则表达式的直接翻译，DFA 可以认为是一种特殊的 NFA，它最大的特点就是确定性。它的确定性在于，在一个状态下，输入一个符号，一定是转换到确定的状态，没有其他的可能性</p><p>而NFA是不确定的，同样的输入可能有不同的输出，因此需要把NFA转为DFA，转化方法有Thompson算法，这里就不细展开了</p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>对词法分析器进行代码实现，我们首先实现<code>getNextChar</code>函数，该函数的作用是匹配一个字符，并将指针移动到下一个字符<br></p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNextChar</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">self</span>.current_column += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.current_raw &gt;= len(<span class="hljs-keyword">self</span>.source_code)<span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.EOF<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.current_column &gt;= len(<span class="hljs-keyword">self</span>.source_code[<span class="hljs-keyword">self</span>.current_raw])<span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.current_raw += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">self</span>.current_column = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">'\\n'</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.source_code[<span class="hljs-keyword">self</span>.current_raw][<span class="hljs-keyword">self</span>.current_column]<br></code></pre></td></tr></tbody></table></figure><br>有时候我们需要向前看一位，<br><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lookahead</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>    ch = <span class="hljs-keyword">self</span>.getNextChar()<br>    <span class="hljs-keyword">self</span>.back()<br>    <span class="hljs-keyword">return</span> ch<br></code></pre></td></tr></tbody></table></figure><br>然后我们识别变量(IDENTIFY)，注意到IDENTIFY的DFA图很容易可以画出来，我们定义一个变量首字母必须以字母或下划线开头，然后可以接字母或下划线或数字。如果遇到其他字符（如分隔符或空格），则表示该变量结束匹配<p></p><p>因此画出DFA，代码如下：<br></p><figure class="highlight pf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">def recognizeId(<span class="hljs-literal">self</span>, ch):<br>    '''识别标志符 Identity，包括关键词'''<br>    <span class="hljs-keyword">state</span> = <span class="hljs-number">0</span><br>    str_id = ''<br>    while <span class="hljs-keyword">state</span> != <span class="hljs-number">2</span>:<br>        if <span class="hljs-keyword">state</span> == <span class="hljs-number">0</span>:<br>            if ch.isalpha() or ch == '_':<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">1</span><br>                str_id += ch<br>            else:<br>                raise ValueError('Failed <span class="hljs-keyword">to</span> recognizeId ch: {}'.format(ch))<br>        if <span class="hljs-keyword">state</span> == <span class="hljs-number">1</span>:<br>            ch = <span class="hljs-literal">self</span>.getNextChar()<br>            if ch.isalpha() or ch.isdigit() or ch == '_':<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">1</span><br>                str_id += ch<br>            else:<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">2</span><br>    <span class="hljs-comment">#这里需要回退一个字符</span><br>    <span class="hljs-literal">self</span>.back()     <br>    return str_id<br></code></pre></td></tr></tbody></table></figure><p></p><p>对于注释，我们使用//进行单行注释</p><figure class="highlight pf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pf">def recognizeComment(<span class="hljs-literal">self</span>, ch):<br>    <span class="hljs-keyword">state</span> = <span class="hljs-number">0</span><br>    str = ''<br>    while <span class="hljs-keyword">state</span> != <span class="hljs-number">3</span>:<br>        if <span class="hljs-keyword">state</span> == <span class="hljs-number">0</span>:<br>            if ch == '/':<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">1</span><br>                str += ch<br>            else:<br>                raise ValueError('Failed <span class="hljs-keyword">to</span> recognizeComment ch: {}'.format(ch))<br>        if <span class="hljs-keyword">state</span> == <span class="hljs-number">1</span>:<br>            if ch == '/':<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">2</span><br>                str += ch<br>            else:<br>                raise ValueError('Failed <span class="hljs-keyword">to</span> recognizeComment ch: {}'.format(ch))<br>        if <span class="hljs-keyword">state</span> == <span class="hljs-number">2</span>:<br>            ch = <span class="hljs-literal">self</span>.getNextChar()<br>            if ch != '\\n':<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">2</span><br>                str += ch<br>            else:<br>                <span class="hljs-keyword">state</span> = <span class="hljs-number">3</span><br>    <span class="hljs-literal">self</span>.back()<br>    return str<br></code></pre></td></tr></tbody></table></figure><p>其他识别同理不再赘述</p><p>最后，使用<code>scanner</code>函数对所有识别方式进行整合，根据得到的不同字符来选择不同的识别方法，并将结果保存在<code>TOKEN</code>列表中<br></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">def scanner(self):<br>    ch = ''<br>    <span class="hljs-keyword">while</span> ch != <span class="hljs-character">'\0'</span>:<br>        ch = self.get<span class="hljs-constructor">NextChar()</span><br>        <span class="hljs-keyword">if</span> ch<span class="hljs-operator"> == </span><span class="hljs-character">' '</span>:<br>            pass<br>        elif ch<span class="hljs-operator"> == </span><span class="hljs-character">'\n'</span>:<br>            self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID['\\<span class="hljs-identifier">n</span>']</span>, ch])<br>        elif ch.isalpha<span class="hljs-literal">()</span> <span class="hljs-keyword">or</span> ch<span class="hljs-operator"> == </span><span class="hljs-character">'_'</span>:<br>            Identify = self.recognize<span class="hljs-constructor">Id(<span class="hljs-params">ch</span>)</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Token</span>.</span></span>is<span class="hljs-constructor">KEYWORD(Identify)</span>:<br>                self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID[I<span class="hljs-identifier">dentify</span>]</span>, Identify])<br>            <span class="hljs-keyword">else</span>:<br>                self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID['I<span class="hljs-identifier">dentify</span>']</span>, Identify])<br>        elif ch.isdigit<span class="hljs-literal">()</span>:<br>            Integer = self.recognize<span class="hljs-constructor">Integer(<span class="hljs-params">ch</span>)</span><br>            self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID['INT']</span>, Integer])<br>        elif <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Token</span>.</span></span>is<span class="hljs-constructor">OPERATOR(<span class="hljs-params">ch</span>)</span>:<br>            <span class="hljs-keyword">if</span> ch<span class="hljs-operator"> == </span><span class="hljs-character">'/'</span> <span class="hljs-keyword">and</span> self.lookahead<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-character">'/'</span>:<br>                self.recognize<span class="hljs-constructor">Comment(<span class="hljs-params">ch</span>)</span><br>                self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID['\\<span class="hljs-identifier">n</span>']</span>, <span class="hljs-character">'\n'</span>])<br>            <span class="hljs-keyword">else</span>:<br>                Op = self.recognize<span class="hljs-constructor">Op(<span class="hljs-params">ch</span>)</span><br>                self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID[O<span class="hljs-identifier">p</span>]</span>, Op])<br>        elif <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Token</span>.</span></span>is<span class="hljs-constructor">SEPARATOR(<span class="hljs-params">ch</span>)</span>:<br>            self.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TOKEN</span>.</span></span>append(<span class="hljs-literal">[T<span class="hljs-identifier">oken</span>.TOKENID[<span class="hljs-identifier">ch</span>]</span>, ch])<br>        <span class="hljs-keyword">else</span>:<br>            raise <span class="hljs-constructor">ValueError('Failed <span class="hljs-params">to</span> <span class="hljs-params">scanner</span> <span class="hljs-params">ch</span>: {}'.<span class="hljs-params">format</span>(<span class="hljs-params">ch</span>)</span>)<br></code></pre></td></tr></tbody></table></figure><p></p><p>下面执行该词法分析器，生成TOKEN串如下所示：<br></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">// 源代码<br>func add(a, b){<br>    return a+b<br>}<br>three = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br>// 生成<span class="hljs-symbol">Token</span>串<br>[[<span class="hljs-number">105</span>, <span class="hljs-string">'func'</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'add'</span>], [<span class="hljs-number">300</span>, <span class="hljs-string">'('</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'a'</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'b'</span>], [<span class="hljs-number">301</span>, <span class="hljs-string">')'</span>], [<span class="hljs-number">304</span>, <span class="hljs-string">'{'</span>], [<span class="hljs-number">308</span>, <span class="hljs-string">'\n'</span>], [<span class="hljs-number">106</span>, <span class="hljs-string">'return'</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'a'</span>], [<span class="hljs-number">400</span>, <span class="hljs-string">'+'</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'b'</span>], [<span class="hljs-number">308</span>, <span class="hljs-string">'\n'</span>], [<span class="hljs-number">305</span>, <span class="hljs-string">'}'</span>], [<span class="hljs-number">308</span>, <span class="hljs-string">'\n'</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'three'</span>], [<span class="hljs-number">406</span>, <span class="hljs-string">'='</span>], [<span class="hljs-number">500</span>, <span class="hljs-string">'add'</span>], [<span class="hljs-number">300</span>, <span class="hljs-string">'('</span>], [<span class="hljs-number">600</span>, <span class="hljs-string">'1'</span>], [<span class="hljs-number">600</span>, <span class="hljs-string">'2'</span>], [<span class="hljs-number">301</span>, <span class="hljs-string">')'</span>], [<span class="hljs-number">308</span>, <span class="hljs-string">'\n'</span>]]<br></code></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guitar|曲谱</title>
      <link href="2020/11/09/guitar-1/"/>
      <url>2020/11/09/guitar-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近在练习吉他和弦，于是在这里收集一些我自己喜欢的吉他谱，希望能早日弹出流利的曲子<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>以后会在这里继续更新~</p><h2 id="0x01-弹唱曲谱"><a href="#0x01-弹唱曲谱" class="headerlink" title="0x01 弹唱曲谱"></a>0x01 弹唱曲谱</h2><h2 id="指弹"><a href="#指弹" class="headerlink" title="指弹"></a>指弹</h2><h3 id="童话镇"><a href="#童话镇" class="headerlink" title="童话镇"></a>童话镇</h3><p><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432-50.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010433.jpg" alt=""></p><h3 id="成都"><a href="#成都" class="headerlink" title="成都"></a>成都</h3><p><img src="https://jita.lu/uploads/bd0ac235cef4f1b73b2808c2dfdf80d0.gif" alt=""><br><img src="https://jita.lu/uploads/ab3dac461e022c3dd86f590f9a9f650a.gif" alt=""><br><img src="https://jita.lu/uploads/c693fe3b39929628885aeef821740c4a.gif" alt=""><br><img src="https://jita.lu/uploads/a5e099ce81d8a15f26c086bdfb5d434e.gif" alt=""><br><img src="https://jita.lu/uploads/79c12ff7fe220ad20b70c927120227e5.gif" alt=""><br><img src="https://jita.lu/uploads/9fde0538dd4fdf3f3315d285080fc2b4.gif" alt=""></p><h2 id="扫弦"><a href="#扫弦" class="headerlink" title="扫弦"></a>扫弦</h2><h3 id="当你"><a href="#当你" class="headerlink" title="当你"></a>当你</h3><p><img src="https://jita.lu/uploads/fb5575f63a0892715215e097447ab0b8.png" alt=""><br><img src="https://jita.lu/uploads/30d11e5de2d8d27fb4f8e5097b7b656d.png" alt=""><br><img src="https://jita.lu/uploads/e1d51a279f0fce7fc20b2a1f1769e853.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guitar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原理|Vue：MVVM实现</title>
      <link href="2020/10/25/vue-1/"/>
      <url>2020/10/25/vue-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近Vue.js特别火，对于它的mvvm的特性，我感到特别好奇，于是通过尤大的话了解到，Vue使用了JavaScript的 <code>Object.defineProperty</code>函数来实现数据的双向绑定。</p><p>这里，我将记录该方法的学习成果，也算是一个总结吧 ￣へ￣ </p><h2 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>首先看 <code>MDN</code> 上对该方法的描述：<br></p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">obj</span>, <span class="hljs-params">prop</span>, <span class="hljs-params">descriptor</span>)</span><br><br>obj<br>要在其上定义属性的对象。<br>prop<br>要定义或修改的属性的名称。<br>descriptor<br>将被定义或修改的属性描述符。 <br><br>返回值<br>被传递给函数的对象。<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>创建属性</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = {}<br><br><span class="hljs-comment">// 在对象中添加一个属性与数据描述符的示例</span><br><span class="hljs-built_in">Object</span>.defineProperty(person,<span class="hljs-string">'age'</span>,{<br>    configurable:<span class="hljs-literal">false</span>,<span class="hljs-comment">//configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。</span><br>    enumerable:<span class="hljs-literal">false</span>,<span class="hljs-comment">//对象属性是否可通过for-in循环，false为不可循环，默认值为true</span><br>    writable:<span class="hljs-literal">false</span>,<span class="hljs-comment">//对象属性是否可修改,false为不可修改，默认值为true</span><br>    value:<span class="hljs-string">'17'</span> <span class="hljs-comment">//对象属性的默认值，默认值为undefined</span><br>});<br><br><span class="hljs-comment">//writable</span><br>person.age=<span class="hljs-string">"71"</span>;<br><span class="hljs-built_in">console</span>.log(person);<span class="hljs-comment">//17，不可修改value，而且在严格模式下会抛出错误</span><br><br><span class="hljs-comment">//enumerable</span><br>person.name = <span class="hljs-string">"Allen"</span>; 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为<span class="hljs-literal">true</span><br><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> person</span>)</span>{<br>    <span class="hljs-built_in">console</span>.log(person[i]) <span class="hljs-comment">//无结果，不可循环</span><br>}<br><br><span class="hljs-comment">//configurable</span><br><span class="hljs-keyword">delete</span> person.age<br><span class="hljs-built_in">console</span>.log(person.age)<span class="hljs-comment">//17，不可删除</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(person,<span class="hljs-string">'age'</span>,{<br>    configurable:<span class="hljs-literal">true</span> <span class="hljs-comment">//不可修改，将抛出错误</span><br>});<br></code></pre></td></tr></tbody></table></figure><p>2.一般的 Setters 和 Getters</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Factory</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> factory = [];<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>, <span class="hljs-string">'temperature'</span>,{<br>get: <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'get!'</span>);<br>},<br>set: <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {<br>value = val;<br>factory.push(val);<br>}<br>});<br><br><span class="hljs-built_in">this</span>.getFactory = <span class="hljs-function">() =&gt;</span> factory;<br>}<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> Factory();<br>f.temperature;<span class="hljs-comment">//打印 get!</span><br>f.temperature = <span class="hljs-number">22</span>;<br>f.temperature = <span class="hljs-number">33</span>;<br><span class="hljs-built_in">console</span>.log(f.getFactory());<span class="hljs-comment">//打印 [22,33]</span><br></code></pre></td></tr></tbody></table></figure><p>可以看到，当数据获取或者改变时，会调用函数的<code>get</code>或<code>set</code>方法，如此，再辅以视图层的操作，便实现了数据的双向绑定</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>进一步，我们还没有满足：那<code>Vue</code>是如何使用这个方法做到的呢？</p><p>为了解决这个疑问，我们不得不翻开<code>Vue.js</code>的源代码一览究竟</p><p>翻开Vue源代码，可以看到里面普遍使用了<code>Object.defineProperty</code>方法，但是里面拓展了Property来避开<code>Object.defineProperty</code>，其实原理是一样的。如下面<code>Vue</code>的源码片段所示<br></p><figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">// For props<span class="hljs-built_in"> and </span>computed properties, we define the proxy getters on<br>// the Vue instances at extension time, on the extended prototype. This<br>// avoids Object.defineProperty calls for each<span class="hljs-built_in"> instance </span>created.<br>if (Sub.options.props) {<br>    initProps(Sub)<br>}<br>if (Sub.options.computed) {<br>    initComputed(Sub)<br>}<br></code></pre></td></tr></tbody></table></figure><p></p><hr><p>对于Vue来说，它并不是单纯地通过数据和dom节点的绑定来绑定数据，它在网页dom和accessor之间会有两层，一层是Wacher，一层是Directive。如下图所示</p><p><img src="/img/vue-1.png" alt=""></p><p>如果我们通过代码修改了<code>a.b</code>的值，那么<code>set</code>函数就会通知Watcher，再由Watcher通知Directive修改Dom里<code>a.b</code>的值</p><h2 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h2><p>那么，如果我们要来实现Vue的功能，代码我们该怎么写呢？这里有一个小小的例子供你参考</p><p>html页面：<br></p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"app"</span>&gt;<br>Hello World!<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></tbody></table></figure><br>主体部分<br><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//模仿Vue操作dom的语法</span><br><span class="hljs-comment">//我们自己创建一个Vue函数</span><br><span class="hljs-keyword">const</span> Vue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{el, data={message:<span class="hljs-string">''</span>}}</span>)</span>{<br><span class="hljs-comment">//绑定 get和set方法</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>,<span class="hljs-string">'message'</span>,{<br>get: <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(el).innerHTML<br>},<br>set: <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {<br><span class="hljs-built_in">document</span>.getElementById(el).innerHTML = val<br>}<br>})<br>}<br><br><span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> Vue({<br>el: <span class="hljs-string">'app'</span>,<br>data: {<br>message: <span class="hljs-string">'Wooooooooooo!'</span><br>}<br>})<br>v.message<span class="hljs-comment">//返回 Wooooooooooo! 字符串</span><br>v.message = <span class="hljs-string">'ohhhhhhhhhhh!'</span><span class="hljs-comment">//将div内的内容变为 ohhhhhhhhhhh!</span><br></code></pre></td></tr></tbody></table></figure><br>这样，就能进行数据交互了。<p></p><p>可以看到，所谓各种库和框架，它们并没有在底层层面上创造新的东西，而只是把原有的概念进行了封装与重组。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（3）：线性代数基础</title>
      <link href="2020/10/24/qc-3/"/>
      <url>2020/10/24/qc-3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>传统计算机使用比特 0 和 1 以及它们之间的逻辑操作 and，or，not，xor 等位运算构造加减乘除，并搭建整个经典计算机体系。</p><p>在量子计算机上，基本的存储单元是量子位，即 Qubit。只要搞明白了 Qubit，以及它们之间的逻辑操作，原理上就可以搭建量子计算机。</p><p>Qubit 可以是任意两个本征态<code>|0&gt;</code>和<code>|1&gt;</code>，或者是它们的线性叠加</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>其中<code>α、β</code>是复数</p><p>可以用向量形式来表示狄拉克符号：</p><script type="math/tex; mode=display">\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix},\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}</script><p>在物理意义上，这对应着薛定谔的猫的状态：0——死，1——生。此时这只猫属于既死又活状态，且概率由<code>α、β</code>决定。</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>这里列举的都是最常用的概念，其他的遇到时再查阅资料即可</p><h3 id="1-线性独立"><a href="#1-线性独立" class="headerlink" title="1. 线性独立"></a>1. 线性独立</h3><p>对于一个矢量集$\mathinner{|\alpha_1\rangle},…,\mathinner{|\alpha_n\rangle}\in V$，如果对于复数$c_i$，当且仅当$c_1=…=c_m=0$时，关系式</p><script type="math/tex; mode=display">c_1\mathinner{|\alpha_1\rangle}+...+c_n\mathinner{|\alpha_n\rangle}=0</script><p>才成立，我们称这些矢量线性独立。</p><h3 id="2-内积"><a href="#2-内积" class="headerlink" title="2. 内积"></a>2. 内积</h3><p>$\mathinner{|\alpha\rangle}、\mathinner{|\beta\rangle}$的内积满足以下性质：</p><ul><li>反称：$\mathinner{\langle\alpha|\beta\rangle}=\mathinner{\langle\beta|\alpha\rangle}^*$</li><li>线性：$\mathinner{\langle\alpha|c\beta+d\gamma\rangle}=c\mathinner{\langle\alpha|\beta\rangle}+d\mathinner{\langle\alpha|\gamma\rangle}$</li><li>正定：$\mathinner{\langle\alpha|\beta\rangle}\ge 0$<br>作为例子，我们定义两个矢量$\mathinner{|\alpha\rangle}=(\alpha_1,…,\alpha_n)$和$\mathinner{|\beta\rangle}=(\beta,…,\beta)$在$C^n$中的内积为<script type="math/tex; mode=display">\mathinner{\langle\alpha|\beta\rangle}=\sum_{i=1}^n\alpha_i^*\beta_i</script></li></ul><h3 id="3-模"><a href="#3-模" class="headerlink" title="3. 模"></a>3. 模</h3><script type="math/tex; mode=display">||\mathinner{|\alpha\rangle}||=\mathinner{\langle\alpha|\alpha\rangle}=\sum_{i=1}^n\alpha_i^*\alpha_i</script><p>量子力学把一个物理系统的态和希尔伯特空间中的单位矢量联系起来，在物理现象和数学之间建立了一座桥梁，这个桥梁便是线性代数。</p><h3 id="4-线性算符"><a href="#4-线性算符" class="headerlink" title="4. 线性算符"></a>4. 线性算符</h3><p>一个算符A将矢量$\mathinner{|\alpha\rangle}\in V$映射到另一个矢量$\mathinner{|\beta\rangle}\in V$，即</p><script type="math/tex; mode=display">\mathinner{|\beta\rangle}=A\mathinner{|\alpha\rangle}</script><p>注意到，对量子比特的操作都是通过线性算符实现的。</p><p>在物理意义上，线性算符就是特定波长频率的射线，用来影响量子比特的行为。</p><p>如果对于$\forall \mathinner{|\alpha\rangle}\in V,A\mathinner{|\alpha\rangle}=B\mathinner{|\alpha\rangle}$，则A和B算符是相等的，记为A=B。</p><p>两个线性算符A和B之和C=A+B也是线性的，为</p><script type="math/tex; mode=display">C\mathinner{|\alpha\rangle}=(A+B)\mathinner{|\alpha\rangle}=A\mathinner{|\alpha\rangle}+B\mathinner{|\alpha\rangle}</script><h3 id="5-泡利矩阵"><a href="#5-泡利矩阵" class="headerlink" title="5. 泡利矩阵"></a>5. 泡利矩阵</h3><p>泡利矩阵是经常用到的一种矩阵，</p><script type="math/tex; mode=display">\sigma_x=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix}，\sigma_y=\begin{pmatrix}0 & -i\\ i & 0\\\end{pmatrix}，\sigma_z=\begin{pmatrix}1 & 0\\ 0 & -1\\\end{pmatrix}</script><p>且它有良好的性质：<br>1) $\sigma_x^2=\sigma_y^2=\sigma_z^2=I$ 其中I是单位阵<br>2) $\sigma_x\sigma_y=i\sigma_z，\sigma_y\sigma_z=i\sigma_x，\sigma_z\sigma_x=i\sigma_y$</p><h3 id="6-投影算符"><a href="#6-投影算符" class="headerlink" title="6. 投影算符"></a>6. 投影算符</h3><p>投影算符是用来测量的一种算符，如果$\mathinner{|\alpha\rangle}\in V$是单位矢量，在$\mathinner{|\alpha\rangle}$的一维投影定义如下：</p><script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}=P_\alpha\mathinner{|\gamma\rangle}=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>该算符叫做投影算符，它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p><h3 id="7-么正算符"><a href="#7-么正算符" class="headerlink" title="7. 么正算符"></a>7. 么正算符</h3><p>若</p><script type="math/tex; mode=display">UU^+=U^+U=I</script><p>则称U是么正的，即酉矩阵，从定义中我们知道，U的伴随算符就是它的逆，即</p><script type="math/tex; mode=display">U^+=U^{-1}</script><p>此外，两个么正算符的乘积UV也是么正的，这是量子门串联的基础</p><script type="math/tex; mode=display">(UV)(UV)^+=UVU^+V^+=I</script><p>么正算符的性质非常重要，因为么正算符不改变一个矢量的模，因此么正算符对希尔伯特空间中的矢量的作用，相当于欧几里得空间的坐标旋转。</p><p>所以量子门都是么正算符。</p><h3 id="8-张量积"><a href="#8-张量积" class="headerlink" title="8. 张量积"></a>8. 张量积</h3><p>在希尔伯特空间$\mathcal{H}=\mathcal{H}_1\otimes\mathcal{H}_2$中，对于矢量$\mathinner{|\alpha\rangle}\in\mathcal{H}_1$，$\mathinner{|\beta\rangle}\in\mathcal{H}_2$，都有一个矢量与它们相联系，且后者称为前两者的张量积，记为$\mathinner{|\alpha\rangle}\otimes\mathinner{|\beta\rangle}$</p><p>经常用简写$\mathinner{|\alpha\rangle}\mathinner{|\beta\rangle}，\mathinner{|\alpha\beta\rangle}，\mathinner{|\alpha,\beta\rangle}$来表示张量积</p><h2 id="0x02-单比特系统"><a href="#0x02-单比特系统" class="headerlink" title="0x02 单比特系统"></a>0x02 单比特系统</h2><p>一个量子位可以表示为一个布洛赫球上的向量，对量子位的操作就是旋转这个向量<br><img src="/img/qc-3-1.png" alt=""><br>而旋转操作是用量子门来实现的，要注意的一点是为了满足归一性，量子门必须是酉矩阵</p><p>有一些常用的单量子门，如<code>NOT</code>门</p><script type="math/tex; mode=display">NOT=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix},NOT\mathinner{|0\rangle}=\mathinner{|1\rangle},NOT\mathinner{|1\rangle}=\mathinner{|0\rangle}</script><p><code>NOT</code>门的作用是将量子比特翻转，对应在布洛赫球上的几何意义是将向量翻转</p><h2 id="0x03-多比特系统"><a href="#0x03-多比特系统" class="headerlink" title="0x03 多比特系统"></a>0x03 多比特系统</h2><p>多量子比特之间的关系是用张量积来描述的，比如两量子比特系统有4种基本状态，</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}1\\ 0\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 1\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\1\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\0\\1\\\end{pmatrix}</script><p>对于一般的两量子系统，可写作</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\alpha_{00}\mathinner{|00\rangle}+\alpha_{01}\mathinner{|01\rangle}+\alpha_{10}\mathinner{|10\rangle}+\alpha_{11}\mathinner{|11\rangle}</script><p>而双量子门则为4*4的矩阵，例如CNOT门</p><script type="math/tex; mode=display">CNOT=\begin{pmatrix}1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\0 & 0 & 1 & 0\\\end{pmatrix}</script><p>它的作用是，当控制位为1时，翻转目标位，否则不变。</p><p>代入矩阵运算很容易验证，</p><script type="math/tex; mode=display">CNOT\mathinner{|00\rangle}=\mathinner{|00\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|01\rangle}=\mathinner{|01\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|10\rangle}=\mathinner{|11\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|11\rangle}=\mathinner{|10\rangle}</script><h2 id="0x04-量子纠缠"><a href="#0x04-量子纠缠" class="headerlink" title="0x04 量子纠缠"></a>0x04 量子纠缠</h2><p>一言以蔽之，在线性代数的视角下，量子纠缠就是无法将态分解成张量积的形式。若</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=H_1 \otimes H_2, \exists \mathinner{|\alpha\rangle}\in H_1, \exists \mathinner{|\beta\rangle}\in H_2 s.t. \mathinner{|\varphi\rangle}=\mathinner{|\alpha\rangle}\otimes \mathinner{|\beta\rangle}</script><p>则该量子态不纠缠。举个例子，有两个双量子系统，分别为$\varphi_1$、$\varphi_2$</p><script type="math/tex; mode=display">\mathinner{|\varphi_1\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|11\rangle})</script><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|01\rangle})</script><p>其中$\varphi_1$处于纠缠态，而$\varphi_2$不处于纠缠态，原因在于</p><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}\mathinner{|0\rangle}\otimes (\mathinner{|0\rangle}+\mathinner{|1\rangle})</script><p>$\varphi_2$可以被分解成张量积的形式</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（2）：量子力学基础</title>
      <link href="2020/10/23/qc-2/"/>
      <url>2020/10/23/qc-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-量子力学公理"><a href="#0x01-量子力学公理" class="headerlink" title="0x01 量子力学公理"></a>0x01 量子力学公理</h2><ol><li>每个物理系统都与希尔伯特空间有关。希尔伯特空间是一个向量空间加上一个内积<code>&lt;a|b&gt;</code>，其满足: </li></ol><ul><li>复共轭关系: <code>&lt;a|b&gt; = &lt;b|a&gt;*</code></li><li>线性关系：<code>&lt;x*a1 + y*a2|b&gt; = x&lt;a1|b&gt; + y&lt;a2|b&gt;</code></li><li>正定性：<code>&lt;a|a&gt; ≥ 0</code></li></ul><ol><li>希尔伯特空间中的每一个<code>raw</code>都与系统的一个状态有关。我们有时称这些<code>raw</code>为<code>kets</code>，并给它们贴上标签，如 <code>|φ&gt;</code>。其对偶向量由<code>bras</code>表示，并标记为<code>&lt;φ|</code>。在矩阵表示中，<code>kets</code>是列向量，而<code>bras</code>是<code>kets</code>的共轭转置，是行向量</li><li>每个测量都对应于埃尔米特算子<code>A = A† = AT*</code></li><li>测量的结果可能是<code>A</code>的特征值</li><li>观测到某一特定值的概率为<script type="math/tex; mode=display">Prob(a=a_n) = \frac{<\varphi|P_{a_n}|\varphi>}{<\varphi|\varphi>}</script></li></ol><p>在这里，<code>Pan</code>是对应于给定测量值的状态集(这也被称为A的特征空间)上的投影。这个表达式中的分母是处理状态向量时没有正确归一化的情况</p><h2 id="0x02-测量"><a href="#0x02-测量" class="headerlink" title="0x02 测量"></a>0x02 测量</h2><p>假设我们有一个三维希尔伯特空间由正交基向量组成，<code>|0&gt;,|1&gt;,|2&gt;</code>，因为它们正交，其内积是<code>&lt;0|1&gt;=&lt;0|2&gt;=&lt;1|2&gt;=0，&lt;0|0&gt;=&lt;1|1&gt;=&lt;2|2&gt;=1</code>，取一个希尔伯特空间的特殊状态：</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=\begin{pmatrix}{}\frac{1}{\sqrt{3}}\\\frac{1}{\sqrt{3}}\\\frac{i}{\sqrt{3}}\\\end{pmatrix}</script><p>这种状态是量子叠加的一个例子，其中系统的状态是基状态的和。我们已经使用了<code>bra-ket</code>符号来表示状态，同时也使用了列向量表示状态，其中列向量中的元素对应于bra-ket符号中基向量前面的系数。基向量前面的系数称为振幅，在任何给定的基状态下找到系统的概率由这个基向量振幅的模的平方得到。在上式中，振幅都是1/3  </p><p>注意，使用上面的公理也可以确定这些概率。例如，求找到系统在<code>|0&gt;</code>状态的概率是多少?  </p><p>根据公理5，概率是以投影的形式给出的(我们将忽略分母，因为在标准化的状态下:<code>&lt;φ|φ&gt;=1</code>)，而投影到<code>|0&gt;</code>状态的是算子为：</p><script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=\left(\begin{array}{c}1\\0\\0\\\end{array}\right)\left(\begin{array}{c}1 & 0 & 0\\\end{array}\right)</script><p>同时，</p><script type="math/tex; mode=display">\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=\begin{pmatrix}\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\\end{pmatrix}</script><p>因此我们可以计算出内积</p><script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p><h2 id="0x03-组合量子系统"><a href="#0x03-组合量子系统" class="headerlink" title="0x03 组合量子系统"></a>0x03 组合量子系统</h2><p>很显然不可能只研究一个量子比特的系统，为了进行计算，往往需要研究多量子系统的希尔伯特空间。</p><p>组合的量子系统可以使用kronecker积来表示。</p><p>考虑两个1量子位的希尔伯特空间的集合，那么他们组合的情况一共有4种，分别是<code>{|00&gt;,|01&gt;,|10&gt;,|11&gt;}</code>，每增加一个量子位，可表示的维度便翻一倍。这种组合称为kronecker积（或者张量积）：</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\left(\begin{array}{c}1\\0\\\end{array}\right)\otimes\left(\begin{array}{c}1\\0\\\end{array}\right)=\left(\begin{array}{c}1\\0\\0\\0\\\end{array}\right)</script><p>可见，模拟经典力学是一个难易程度只像粒子数目的多项式一样增加的问题，而模拟量子力学是一个难易程度随粒子数目呈指数级增加的问题</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（1）：体系结构</title>
      <link href="2020/10/21/qc-1/"/>
      <url>2020/10/21/qc-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>　　作为一个工程师，我习惯于对任何看起来神秘的事物刨根问底，量子计算同样如此。看到一辆玩具小车在横冲直撞，我会思考这是因为电池驱动的马达带动轴承做旋转运动；看到日升日落，我会思考这是由于万有引力的束缚，抑或是广义相对论的时空约束。<br>　　万物均有体系结构，就算是看起来最反常识的量子力学，也接受薛定谔方程的描述。因此，我把<code>体系结构</code>作为本系列的第一篇文章，作为对自己知识的梳理。<br>　　或许是我担任”计算机组成与体系结构”这门课程助教的原因:)，体系结构这个话题可以聊的就太多了。然而我毕竟不是搞的芯片，因此本文从工程的角度出发，对比经典与量子两种架构，对其进行一个全面的阐述。  </p><h2 id="0x01-经典架构"><a href="#0x01-经典架构" class="headerlink" title="0x01 经典架构"></a>0x01 经典架构</h2><p>　　首先讨论经典计算机的架构，先从最基本的单元说起。<br>　　经典计算机基本单元是比特0-1，用高电平和低电平来表示。比特的基本处理单元是逻辑门，而逻辑门使用晶体管实现。同时使用晶体管可以来构建存储单元SRAM、DRAM，前者是register、cache的主要成分，后者则是memory的主要成分。同样的，像是CPU中的处理单元加法器、算术逻辑单元等等，这些都可以通过晶体管构成。存储单元和处理单元是可以分开的，所以我们有非常出名的冯诺依曼体系结构，它告诉人们一台计算机可以用什么样的方式搭建出来。  </p><p><img src="/img/qc-1-1.png" alt="Fig. 1: MIPS microarchitecture"></p><p>　　上图是一个极度简化的CPU的组成，它包含几个部分，总的概括便是存储器和算术逻辑单元，为了让存储和运算单元组合到一起工作，于是有一个控制器。这些所有单元都是由晶体管构成，所以我们说，数据的存储、处理、控制都是同质的（homogeneous），因此我们可以把它集成到同一块芯片上来。<br>　　有了这样一个架构，我们就可以在上面运行软件了。比如有一个AI应用，它是用编程语言python来实现的，经过编译器进行编译，生成了二进制文件。这些二进制的指令，便放在处理器上面执行。于是经典计算机自顶向下的流程便结束了。  </p><p><img src="/img/qc-1-2.png" alt="">  </p><h2 id="0x02-量子架构"><a href="#0x02-量子架构" class="headerlink" title="0x02 量子架构"></a>0x02 量子架构</h2><p>　　有了经典架构做铺垫，再看量子环境会有什么不同。首先从最基本的单元说起。量子计算机最基本的单元是量子比特（qubit），而量子比特  </p><script type="math/tex; mode=display">\mathinner{|\phi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>表示该比特有|α|^2的概率为0，否则为1。该量子比特处于0和1的叠加态之中。同理，若有n个qubit则系统同时有2^n个状态的叠加。<br>　　量子计算和经典计算不同的一点在于，量子比特既是数据存储的单元，又是数据处理的单元，因此运算过程就发生在量子比特身上。经典计算机使用逻辑门处理比特，而量子计算机使用量子门来处理。量子门处理的过程是对所有比特进行处理，同时有着巨大的状态空间以及巨大的并行性，因此量子算法效率往往会有指数级别的提升。在简单的介绍之后，下面从工程的角度来看一些实物，一个量子芯片到底该长啥样。  </p><p><img src="/img/qc-1-3.png" alt="">  </p><p>　　上图量子芯片来自荷兰代尔夫特理工大学实验室，它在20mK温度下工作，只有两个量子比特[28]（芯片中央两个黑色圆点）。现探索该量子比特的结构。<br>图1.11(a)则为上图量子芯片中的量子比特放大图，可以看到上极板有3个接口，下极板也有3个接口连接出去，两个极板中间有一层介质，它们共同构成了电容。图1.11(b)是该结构的电路图，图中线条标注了它们之间的对应关系。  </p><p><img src="/img/qc-1-4.png" alt="">    </p><p>　　图中黑色线条相连的部分是电容，红色线条相连的部分是约瑟夫森结（Josephson junction）。这两个约瑟夫森结等效于一个电感，于是这个电路中有了电容、电感，就构成了一个LC振荡电路。那么能量就在电容与电感之间来回震荡。如果用量子电动力学去探索它的基态，可以看到它是一个等分的能级的结构，于是我们可以得到这样一个能量间隔不均匀的能级图：  </p><p><img src="/img/qc-1-5.png" alt="">    </p><p>　　取最低能级为0，取第一激发态为1来作为量子态，这样就构成了一个量子比特。注意在这里，我们观测的是整个约瑟夫森结的状态，也就是说观测的量子状态是宏观的，这就相当于用宏观的表现来观测到了微观的量子状态，所以我们才能操作量子比特。<br>　　有了量子比特后，该怎么对量子比特进行操纵呢，这是通过良好定义的波形来实现的。在图1.10中，可以看到该量子芯片周围有6个接口，这些接口通过导线连接到外部，因此能够通过这些接口把波形传到量子比特上面去。比如说单比特门就用20ns的脉冲，通过接口打在量子比特上面去。<br>　　现在回到上面说的问题，在经典计算机中，存储单元和处理单元是分离的。而在量子计算机中，量子比特既是数据存储的地方，又是数据处理的地方，控制媒介则是模拟波形（模拟信号）。经典电路控制媒介则是数字信号。在经典的架构中，有了CPU便可以直接安装软件运行，而在量子计算机中，由于它们是异构的（同时存在模拟/数字信号），则需要一个专门的控制器来进行沟通转换。就是说在软件和量子比特之间一定要引入一个控制器。  </p><p><img src="/img/qc-1-6.png" alt="">    </p><p>　　上图中，AWG（Arbitrary waveform generator）是任意波形发生器的缩写，用它来发射定义好的模拟波形来操作量子比特。Data Collection Card（数据采集卡）用来采集测量量子比特后返回的结果，这个测量结果也是模拟信号，所以要对模拟信号进行识别从而判断结果是0还是1。整个流程便是PC机软件控制发出数字波形，然后控制器中的AWGs发出定义好的模拟波形打在量子比特上，最后测量结果返回给数字采集卡，数字采集卡判断结果后返回给PC主机。这是过去主流的控制量子比特的方法，也是目前少数实验室采用的方法，但是它是不可扩展的，因此后面会提到全栈量子计算机的架构。<br>　　现在可以比较经典计算和量子计算的不同了：  </p><ol><li>从数据流过程上。经典计算是把数据流拿出来运动，经过一个个函数/运算模块中处理，最后得到结果。所以是数据在动，操作不动。而量子计算中，所有数据保存在量子比特上面，我们把操作一个个的打上去，所以是数据不动，操作在动。这种不同也决定了量子计算机的体系结构和经典是不同的。  </li><li>从编程语言上。经典计算发展到现在，有无数编程语言能够满足经典计算的使用。为了描述与操作量子比特，现在也有很多量子高级语言（如Qiskit），然而这些语言经典算法中的高级特性，如递归等操作并没有很好的实现。在使用量子高级语言的时候，更多的是考虑如何实现电路图，这对于量子算法的产生是个很不利的因素。  </li></ol><p>　　在图1.13控制方法中，控制流程是不可扩展的，因此现在主流的组成如下图所示  </p><p><img src="/img/qc-1-7.png" alt="">  </p><p>　　最上层是一些量子算法，如shor算法等等；中间一层是编程语言和编译器，如Qiskit、Q#、QPanda等等；再下面是要转化成的指令集，如eQASM、OpenQASM；最下层便是量子芯片，可能是超导芯片、离子阱等等。<br>　　接下来看看IBM对它的物理实现：  </p><p><img src="/img/qc-1-8.png" alt="">  </p><p>　　上图(a)就是IBM展示的量子计算机，(b)是封装起来的样子，其内部是一个大号的“冰箱”，芯片要求在20mK的温度下工作。    </p><h2 id="0x03-现在-amp-未来"><a href="#0x03-现在-amp-未来" class="headerlink" title="0x03 现在&amp;未来"></a>0x03 现在&amp;未来</h2><p>　　上面说了那么多过去的知识，接下来看看现在此刻的芯片所处的时代~<br>　　学术界预计在未来几年内，我们将进入有噪声中间量子(Noisy Intermediate-Scale Quantum,NISQ)时代，届时具有数十到数百个量子位元的QC器件将面世。<br>　　虽然量子位的数量不足以构成量子纠错(QEC)，但它仍然被期望使用超出可用的经典计算机的能力，来解决现实世界的问题。<br>　　在NISQ时代，由于技术的限制，量子软件和硬件之间存在差距。当前最流行的电路模型设计一个量子程序时，总是假设量子位和量子操作是完美的，你可以应用任何量子物理操作。但在NISQ硬件上，量子位的相干时间有限，量子运算也不完美。下图是 IBM Q20 芯片，可以看到其参数如图  </p><p><img src="/img/qc-1-9.png" alt="Fig. 2:  IBM Q20 Tokyo Information">  </p><p>　　上图显示了有关IBMQ 20芯片的信息，量子比特的平均寿命仅仅约为50µs，同时量子门之间的操作也有错误率，这意味着该芯片将无法运行大规模的程序。量子比特被放置在一个平面几何体上，由于芯片上的放置和路由限制，耦合器只能将一个量子比特连接到相邻的量子比特上。<br>　　有学者估计，要使量子计算机达到通用计算机的程度，至少需要数十万个量子比特，而当前的进展仅仅是几十个比特。或许将量子计算机作为专用计算才是未来的方向，毕竟从理论到实践的路还很漫长…<br>　　事实上，如今的量子计算机是作为云的形式提供服务的，因为目前最流行的超导体系结构无法在室温下工作，所以只能通过提供API的方式调用。这是不是很像云计算？这也是实验室之外唯一能够使用量子芯片的方法了，目前国外有IBM提供的免费量子芯片可供使用（虽然才5比特…），并且需要排队才能申请到使用权限。    </p><p>　　PS：前两天习大大提出要发展量子科技，难道这个冷门中的冷门方向要出头了吗？！惊了！</p><blockquote><p>Reference<br>[1] John Preskill. Quantum computing in the nisq era and beyond. arXiv preprint arXiv:1801.00862, 2018.<br>[2] Sergio Boixo, Sergei V Isakov, Vadim N Smelyanskiy, Ryan Babbush, Nan Ding, Zhang Jiang, Michael J Bremner, John M Martinis, and Hartmut Neven. Characterizing quantum supremacy in near-term devices. Nature Physics, 14(6):595, 2018.<br>[3] IBM. IBM Q Experience Device. <a href="https://quantumexperience.ng.bluemix">https://quantumexperience.ng.bluemix</a>. net/qx/devices, 2018.<br>[4] Li G, Ding Y, Xie Y. Tackling the qubit mapping problem for NISQ-era quantum devices[C]//Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems. 2019: 1001-1014.  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我常用的一些学术资源</title>
      <link href="2020/10/21/xue-zhu-zi-yuan/"/>
      <url>2020/10/21/xue-zhu-zi-yuan/</url>
      
        <content type="html"><![CDATA[<p>不定期更新~<span class="github-emoji"><span>😗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f617.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="0x01-论文相关"><a href="#0x01-论文相关" class="headerlink" title="0x01 论文相关"></a>0x01 论文相关</h2><ul><li>sci-hub可用链接<ul><li><a href="https://sci-hub.shop/">备用1</a></li><li><a href="https://sci-hub.ren/">备用2</a></li><li><a href="https://gfsoso.99lb.net/sci-hub.html">一个综合工具，都不行就用这个</a></li></ul></li><li><a href="http://www.letpub.com.cn/index.php?page=journalapp">中科院分区</a><ul><li>查询论文的级别很好用</li></ul></li><li><a href="http://pss-system.cnipa.gov.cn/sipopublicsearch/portal/uiIndex.shtml">专利检索</a><h2 id="0x02-软件"><a href="#0x02-软件" class="headerlink" title="0x02 软件"></a>0x02 软件</h2></li><li>常用软件的安装<ul><li><a href="http://lookdiv.com/">webstrom激活</a></li><li><a href="https://blog.csdn.net/Slatter/article/details/88730542?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">matlab 2018a</a></li></ul></li></ul><h2 id="0x03-实用网站"><a href="#0x03-实用网站" class="headerlink" title="0x03 实用网站"></a>0x03 实用网站</h2><ul><li><a href="https://www.wolframalpha.com/">wolframalpha</a><ul><li>非常好用的数学计算工具，nice！<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>可识别自然语言，功能非常齐全</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
