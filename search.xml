<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Light|来设计一款编程语言吧(2)：语法分析</title>
      <link href="2020/11/11/light-2/"/>
      <url>2020/11/11/light-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>上一篇blog介绍了Light语言的词法分析程序，生成的Token串就是语法分析的输入。这篇文章将对Light使用的语法分析器进行一个总结</p><p>语法分析器的目的是将Token串生成抽象语法树(AST)，通过抽象语法树可以很容易的生成目标代码，或者进行代码优化等操作</p><p>任何语言都有其语法，Light的语法遵循LL(1)文法设计，下面介绍基本原理与实现</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><h3 id="1-1-LL-1-文法"><a href="#1-1-LL-1-文法" class="headerlink" title="1.1 LL(1)文法"></a>1.1 LL(1)文法</h3><p>LL(1)文法主要目的是为了解决两个痛点问题：</p><ul><li>回溯问题  </li></ul><p>这是一个非终结符具有多个产生式候选带来的问题</p><p>当一个非终结符用某个候选式进行匹配时，匹配成功可能是暂时的</p><p>如果要遍历所有匹配的可能，在每个多候选式终结符进行匹配时，就要记录下当前等待匹配的符号的位置、当前推导句型中非终结符的位置，和该非终结符选择的产生式的序号</p><p>某次匹配失败后，舍弃某些分析结果，回溯到上一个岔路口，走下一条路尝试</p><p>这会导致语法分析的效率问题，此外，最终分析失败时，没法确定应该在哪个岔路口抛出错误</p><ul><li>左递归问题  </li></ul><p>对于类似 x*y 的文法</p><p><img src="https://img-blog.csdnimg.cn/20190803122821496.png" alt=""></p><p>若定义<code>S → xAy  A → A* | *</code>，那么在进行语法分析时很容易产生左递归：</p><p><img src="https://img-blog.csdnimg.cn/20190803123038201.png" alt=""></p><p>在这种情况下，通过将文法转化成LL(1)文法，可以消除上面的两种现象</p><p>这时需要引入First集与Follow集的概念，这里不再赘述。总的来说，LL(1)文法的限制条件为：</p><p>1) 文法不含左递归</p><p>2) 文法中每一个非终结符 A 的各个产生式的候选首符集不相交，即若 A → α1 | α2 | … | αn<br>FIRST(αi)∩FIRST(αj) = ∅，i ≠ j</p><p>3) 对于文法中的每个非终结符 A，若它的某个候选首符集包含 ε，则 FIRST(αi)∩FOLLOW(A) = ∅</p><p>Light语言的部分文法如下所示：</p><pre><code>INT := [0-9]+Array := [a-zA-Z]*\[INT\]Identifier := [_a-zA-Z]+[_a-zA-Z0-9]*Compare := &gt;|&lt;|==|&gt;=|&lt;=Argument    ---------&gt; Identifier | ArrayFactor      ---------&gt; INTExpression  ---------&gt; Factor [+|-|*|/|Compare Expression]Bool        ---------&gt; [!] Identifier|ExpressionIFStatement ---------&gt; if(Bool) { ; Statement}WhileStatement ------&gt; while(Bool) { ; Statement}FuncStatement -------&gt; func Identifier() { ; Statement}Return      ---------&gt; return INT|IdentifierStatement   ---------&gt; IFStatement | WhileStatement | FuncStatementDeclare     ---------&gt; Identifier = FuncStatement|INTProgram     ---------&gt; Declare { ; Statement}FuncCall    ---------&gt; Identifier([INT]*)</code></pre><h3 id="1-2-自上向下的文法分析"><a href="#1-2-自上向下的文法分析" class="headerlink" title="1.2 自上向下的文法分析"></a>1.2 自上向下的文法分析</h3><p>文法分析可以分为自上向下和自下向上，对于Light语言我们采用自上向下的分析方式，同时自上向下的分析主要有递归下降分析和构造LR语法分析表的方法</p><p>在实现文法分析上，我们采用递归下降分析法。<del>主要是为了方便写代码</del></p><p>递归下降分析法被很多编译器采用，如GCC 4.0，LLVM，…</p><p>算法的基本思想是</p><ul><li>每个非终结符构造一个分析函数</li><li>用向前看符号指导产生式规则的规则</li></ul><p>实现方面举个例子，对于一般的语法</p><pre><code>X -&gt; β11 ... β1i   | β21 ... β2j   | β31 ... β3k   | ...</code></pre><p>我们写出它的递归下降分析程序：</p><pre><code>parse_X():    token = nextToken()    switch(token)        case ...:  // β11 ... β1i        case ...:  // β21 ... β2j        case ...:  // β31 ... β3k        ...        default: error("...")</code></pre><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>作为输出对象，首先进行抽象语法树(AST)的构造</p><p>AST可以参考二叉树，与二叉树不同的是，AST可以不只有一个子节点，同时AST的根节点都是非终结符，叶节点都是终结符</p><pre><code>class SyntaxTree(object):    def __init__(self):        self.root = None        self.current = None    def add_child_node(self, new_node, father=None):        passclass SyntaxTreeNode(object):    def __init__(self, value=None, _type=None):        self.value = value        self.type = _type        self.father = None        self.left = None        self.right = None        self.first_son = None</code></pre><p>接下来构造<code>match</code>函数，该函数匹配一个token并将指针向后移一位</p><pre><code>def match(self, token):    if self.lookahead[0] == token[0]:        self.lookahead = self.getNextToken()def getNextToken(self):    self.current_token += 1    if self.current_token &gt;= len(self.TOKEN):        return self.EOF    return self.TOKEN[self.current_token]</code></pre><p>下面给出递归下降分析法的实例，例如对算数表达式进行分析</p><pre><code>parse_E()    parse_T()    match(token)    while(token == +)        parse_T()        match(token)parse_T()    parse_F()    match(token)      while(token == *)        parse_F()        match(token)</code></pre><p>其他语法的分析也是同样的道理，需要对每一个非终结符都编写一个分析函数，根据输入的Token的类型执行相应的分析函数</p><p>最后执行该语法分析器，生成的语法树如下所示：</p><pre><code>// 源代码func add(a, b){    return a+b}three = add(1, 2)// dfs打印语法树( self: Program None,first_son: FuncStatement, father: None, left: None, right: None )( self: FuncStatement None,first_son: add, father: Program, left: None, right: Declare_func )( self: add FuncStatement_Name,first_son: None, father: FuncStatement, left: None, right: ParameterList )( self: ParameterList None,first_son: a, father: FuncStatement, left: add, right: Statement )( self: a 500,first_son: None, father: ParameterList, left: None, right: b )( self: b 500,first_son: None, father: ParameterList, left: a, right: None )( self: Statement None,first_son: Return, father: FuncStatement, left: ParameterList, right: None )( self: Return None,first_son: Expression, father: Statement, left: None, right: None )( self: Expression None,first_son: a, father: Return, left: None, right: None )( self: a 500,first_son: None, father: Expression, left: None, right: + )( self: + 400,first_son: None, father: Expression, left: a, right: b )( self: b 500,first_son: None, father: Expression, left: +, right: None )( self: Declare_func None,first_son: three, father: Program, left: FuncStatement, right: None )( self: three 500,first_son: None, father: Declare_func, left: None, right: = )( self: = 406,first_son: None, father: Declare_func, left: three, right: FuncCall )( self: FuncCall None,first_son: add, father: Declare_func, left: =, right: None )( self: add FuncCall_Name,first_son: None, father: FuncCall, left: None, right: ParameterList )( self: ParameterList None,first_son: 1, father: FuncCall, left: add, right: None )( self: 1 600,first_son: None, father: ParameterList, left: None, right: 2 )( self: 2 600,first_son: None, father: ParameterList, left: 1, right: None )</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light|来设计一款编程语言吧(1)：词法分析</title>
      <link href="2020/11/10/light-1/"/>
      <url>2020/11/10/light-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该系列对Light语言进行一个总结性质的记录，emm勉强算官方文档吧<span class="github-emoji"><span>😝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>Light是一款跨平台轻量级的解释型语言，语法借鉴JavaScript，支持条件语句、循环语句，目前变量支持整数类型、函数类型</p><p>完整项目见我的GitHub</p><p>该语言使用实例如下所示：</p><pre><code>##############################################                 Quick start               ##############################################func add(a, b){    return a+b}three = add(1, 2)print(three)</code></pre><p>具体语法规则放在第二篇blog中介绍，下面开始进行词法分析</p><h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>词法分析处于编译原理的第一环节，目的是将源文件转化成可供语法分析的Token串。在该过程中，需要将变量、数字、关键词、分隔符等都识别出来，并制备成Token格式</p><p>先了解一下词法分析的知识关系图</p><p><img src="https://img-blog.csdnimg.cn/20190112203946406.png" alt=""></p><p>开发一个词法分析器是在词法定义的基础上的，词法定义需要使用正则表达式</p><p>正则表达式可以转换为NFA（Non-determinate finite automata 不确定的有穷自动机），NFA可以转换为DFA（determinate finite automata 确定有穷自动机），DFA可以极小化，进而使用为开发词法分析器的工具</p><p>词法分析器有两种识别方法，分别是关联和独立两种形式，这里我们使用独立的形式，即把词法分析当做是一个独立的整体，并将处理好的结果交给下一步来执行。</p><h3 id="1-1-Token"><a href="#1-1-Token" class="headerlink" title="1.1 Token"></a>1.1 Token</h3><p>定义Token如下：</p><div class="table-container"><table><thead><tr><th>KEYWORD</th><th>tokenID</th><th>SEPARATOR</th><th>tokenID</th><th>OPERATOR</th><th>tokenID</th></tr></thead><tbody><tr><td>if</td><td>100</td><td>(</td><td>300</td><td>+</td><td>400</td></tr><tr><td>elif</td><td>101</td><td>)</td><td>301</td><td>-</td><td>401</td></tr><tr><td>else</td><td>102</td><td>[</td><td>302</td><td>*</td><td>402</td></tr><tr><td>while</td><td>103</td><td>]</td><td>303</td><td>/</td><td>403</td></tr><tr><td>break</td><td>104</td><td>{</td><td>304</td><td>&gt;</td><td>404</td></tr><tr><td>func</td><td>105</td><td>}</td><td>305</td><td>&lt;</td><td>405</td></tr><tr><td>return</td><td>106</td><td>:</td><td>306</td><td>=</td><td>406</td></tr><tr><td>———</td><td>———</td><td>;</td><td>307</td><td>&gt;=</td><td>407</td></tr><tr><td>IDENTIFY</td><td>500</td><td>\n</td><td>308</td><td>&lt;=</td><td>408</td></tr><tr><td>INT</td><td>600</td><td></td><td></td><td>==</td><td>409</td></tr></tbody></table></div><p>下面就不一一列举了…</p><p>一个词法单元(Token)由两部分组成，分别是(id, content)，其中</p><ul><li>关键词(KEYWORD)<br>是具有特殊意义的词，不能被其他方式使用</li><li>分隔符(SEPARATOR)<br>分隔语句，产生语义</li><li>操作符(OPERATOR)<br>进行运算与比较</li><li>变量(IDENTIFY)<br>变量可以是函数，也可以是数</li><li>整数类型(INT)<br>定义整数类型</li></ul><h3 id="1-2-DFA"><a href="#1-2-DFA" class="headerlink" title="1.2 DFA"></a>1.2 DFA</h3><p>DFA是确定有穷自动机，使用DFA来生成我们需要的符号，比如生成一个无符号实数的DFA：</p><p><img src="https://img-blog.csdnimg.cn/20190113124130830.png" alt=""></p><p>对于DFA，我们往往需要把它化成最简，然后就可以直接用代码实现了</p><h3 id="1-3-NFA"><a href="#1-3-NFA" class="headerlink" title="1.3 NFA"></a>1.3 NFA</h3><p>词法分析的一般过程是 regular =&gt; NFA =&gt; DFA =&gt; code</p><p>NFA是对正则表达式的直接翻译，DFA 可以认为是一种特殊的 NFA，它最大的特点就是确定性。它的确定性在于，在一个状态下，输入一个符号，一定是转换到确定的状态，没有其他的可能性</p><p>而NFA是不确定的，同样的输入可能有不同的输出，因此需要把NFA转为DFA，转化方法有Thompson算法，这里就不细展开了</p><h2 id="0x02-编码"><a href="#0x02-编码" class="headerlink" title="0x02 编码"></a>0x02 编码</h2><p>对词法分析器进行代码实现，我们首先实现<code>getNextChar</code>函数，该函数的作用是匹配一个字符，并将指针移动到下一个字符</p><pre><code>def getNextChar(self):    self.current_column += 1    if self.current_raw &gt;= len(self.source_code):        return self.EOF    if self.current_column &gt;= len(self.source_code[self.current_raw]):        self.current_raw += 1        self.current_column = -1        return '\\n'    return self.source_code[self.current_raw][self.current_column]</code></pre><p>有时候我们需要向前看一位，</p><pre><code>def lookahead(self):    ch = self.getNextChar()    self.back()    return ch</code></pre><p>然后我们识别变量(IDENTIFY)，注意到IDENTIFY的DFA图很容易可以画出来，我们定义一个变量首字母必须以字母或下划线开头，然后可以接字母或下划线或数字。如果遇到其他字符（如分隔符或空格），则表示该变量结束匹配</p><p>因此画出DFA，代码如下：</p><pre><code>def recognizeId(self, ch):    '''识别标志符 Identity，包括关键词'''    state = 0    str_id = ''    while state != 2:        if state == 0:            if ch.isalpha() or ch == '_':                state = 1                str_id += ch            else:                raise ValueError('Failed to recognizeId ch: {}'.format(ch))        if state == 1:            ch = self.getNextChar()            if ch.isalpha() or ch.isdigit() or ch == '_':                state = 1                str_id += ch            else:                state = 2    #这里需要回退一个字符    self.back()         return str_id</code></pre><p>对于注释，我们使用//进行单行注释</p><pre><code>def recognizeComment(self, ch):    state = 0    str = ''    while state != 3:        if state == 0:            if ch == '/':                state = 1                str += ch            else:                raise ValueError('Failed to recognizeComment ch: {}'.format(ch))        if state == 1:            if ch == '/':                state = 2                str += ch            else:                raise ValueError('Failed to recognizeComment ch: {}'.format(ch))        if state == 2:            ch = self.getNextChar()            if ch != '\\n':                state = 2                str += ch            else:                state = 3    self.back()    return str</code></pre><p>其他识别同理不再赘述</p><p>最后，使用<code>scanner</code>函数对所有识别方式进行整合，根据得到的不同字符来选择不同的识别方法，并将结果保存在<code>TOKEN</code>列表中</p><pre><code>def scanner(self):    ch = ''    while ch != '\0':        ch = self.getNextChar()        if ch == ' ':            pass        elif ch == '\n':            self.TOKEN.append([Token.TOKENID['\\n'], ch])        elif ch.isalpha() or ch == '_':            Identify = self.recognizeId(ch)            if Token.isKEYWORD(Identify):                self.TOKEN.append([Token.TOKENID[Identify], Identify])            else:                self.TOKEN.append([Token.TOKENID['Identify'], Identify])        elif ch.isdigit():            Integer = self.recognizeInteger(ch)            self.TOKEN.append([Token.TOKENID['INT'], Integer])        elif Token.isOPERATOR(ch):            if ch == '/' and self.lookahead() == '/':                self.recognizeComment(ch)                self.TOKEN.append([Token.TOKENID['\\n'], '\n'])            else:                Op = self.recognizeOp(ch)                self.TOKEN.append([Token.TOKENID[Op], Op])        elif Token.isSEPARATOR(ch):            self.TOKEN.append([Token.TOKENID[ch], ch])        else:            raise ValueError('Failed to scanner ch: {}'.format(ch))</code></pre><p>下面执行该词法分析器，生成TOKEN串如下所示：</p><pre><code>// 源代码func add(a, b){    return a+b}three = add(1, 2)// 生成Token串[[105, 'func'], [500, 'add'], [300, '('], [500, 'a'], [500, 'b'], [301, ')'], [304, '{'], [308, '\n'], [106, 'return'], [500, 'a'], [400, '+'], [500, 'b'], [308, '\n'], [305, '}'], [308, '\n'], [500, 'three'], [406, '='], [500, 'add'], [300, '('], [600, '1'], [600, '2'], [301, ')'], [308, '\n']]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guitar|曲谱</title>
      <link href="2020/11/09/guitar-1/"/>
      <url>2020/11/09/guitar-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近在练习吉他和弦，于是在这里收集一些我自己喜欢的吉他谱，希望能早日弹出流利的曲子<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>以后会在这里继续更新~</p><h2 id="0x01-弹唱曲谱"><a href="#0x01-弹唱曲谱" class="headerlink" title="0x01 弹唱曲谱"></a>0x01 弹唱曲谱</h2><h2 id="指弹"><a href="#指弹" class="headerlink" title="指弹"></a>指弹</h2><h3 id="童话镇"><a href="#童话镇" class="headerlink" title="童话镇"></a>童话镇</h3><p><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010432-50.jpg" alt=""><br><img src="http://www.jitaba.cn/upimg/allimg/1610/1-161026010433.jpg" alt=""></p><h3 id="成都"><a href="#成都" class="headerlink" title="成都"></a>成都</h3><p><img src="https://jita.lu/uploads/bd0ac235cef4f1b73b2808c2dfdf80d0.gif" alt=""><br><img src="https://jita.lu/uploads/ab3dac461e022c3dd86f590f9a9f650a.gif" alt=""><br><img src="https://jita.lu/uploads/c693fe3b39929628885aeef821740c4a.gif" alt=""><br><img src="https://jita.lu/uploads/a5e099ce81d8a15f26c086bdfb5d434e.gif" alt=""><br><img src="https://jita.lu/uploads/79c12ff7fe220ad20b70c927120227e5.gif" alt=""><br><img src="https://jita.lu/uploads/9fde0538dd4fdf3f3315d285080fc2b4.gif" alt=""></p><h2 id="扫弦"><a href="#扫弦" class="headerlink" title="扫弦"></a>扫弦</h2><h3 id="当你"><a href="#当你" class="headerlink" title="当你"></a>当你</h3><p><img src="https://jita.lu/uploads/fb5575f63a0892715215e097447ab0b8.png" alt=""><br><img src="https://jita.lu/uploads/30d11e5de2d8d27fb4f8e5097b7b656d.png" alt=""><br><img src="https://jita.lu/uploads/e1d51a279f0fce7fc20b2a1f1769e853.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guitar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原理|Vue：MVVM实现</title>
      <link href="2020/10/25/vue-1/"/>
      <url>2020/10/25/vue-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近Vue.js特别火，对于它的mvvm的特性，我感到特别好奇，于是通过尤大的话了解到，Vue使用了JavaScript的 <code>Object.defineProperty</code>函数来实现数据的双向绑定。</p><p>这里，我将记录该方法的学习成果，也算是一个总结吧 ￣へ￣ </p><h2 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>首先看 <code>MDN</code> 上对该方法的描述：</p><pre><code>Object.defineProperty(obj, prop, descriptor)    obj        要在其上定义属性的对象。    prop        要定义或修改的属性的名称。    descriptor        将被定义或修改的属性描述符。     返回值        被传递给函数的对象。</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>创建属性</li></ol><pre><code>var person = {}// 在对象中添加一个属性与数据描述符的示例Object.defineProperty(person,'age',{    configurable:false,//configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。    enumerable:false,//对象属性是否可通过for-in循环，false为不可循环，默认值为true    writable:false,//对象属性是否可修改,false为不可修改，默认值为true    value:'17' //对象属性的默认值，默认值为undefined});//writableperson.age="71";console.log(person);//17，不可修改value，而且在严格模式下会抛出错误//enumerableperson.name = "Allen"; 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为truefor(var i in person){    console.log(person[i]) //无结果，不可循环}//configurabledelete person.ageconsole.log(person.age)//17，不可删除Object.defineProperty(person,'age',{    configurable:true //不可修改，将抛出错误});</code></pre><p>2.一般的 Setters 和 Getters</p><pre><code>function Factory(){    var value = null;    var factory = [];    Object.defineProperty(this, 'temperature',{        get: () =&gt; {            console.log('get!');        },        set: val =&gt; {            value = val;            factory.push(val);        }    });    this.getFactory = () =&gt; factory;}var f = new Factory();f.temperature;                    //打印 get!f.temperature = 22;f.temperature = 33;console.log(f.getFactory());    //打印 [22,33]</code></pre><p>可以看到，当数据获取或者改变时，会调用函数的<code>get</code>或<code>set</code>方法，如此，再辅以视图层的操作，便实现了数据的双向绑定</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>进一步，我们还没有满足：那<code>Vue</code>是如何使用这个方法做到的呢？</p><p>为了解决这个疑问，我们不得不翻开<code>Vue.js</code>的源代码一览究竟</p><p>翻开Vue源代码，可以看到里面普遍使用了<code>Object.defineProperty</code>方法，但是里面拓展了Property来避开<code>Object.defineProperty</code>，其实原理是一样的。如下面<code>Vue</code>的源码片段所示</p><pre><code>// For props and computed properties, we define the proxy getters on// the Vue instances at extension time, on the extended prototype. This// avoids Object.defineProperty calls for each instance created.if (Sub.options.props) {    initProps(Sub)}if (Sub.options.computed) {    initComputed(Sub)}</code></pre><hr><p>对于Vue来说，它并不是单纯地通过数据和dom节点的绑定来绑定数据，它在网页dom和accessor之间会有两层，一层是Wacher，一层是Directive。如下图所示</p><p><img src="https://img-blog.csdn.net/20180327221231540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjEyOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果我们通过代码修改了<code>a.b</code>的值，那么<code>set</code>函数就会通知Watcher，再由Watcher通知Directive修改Dom里<code>a.b</code>的值</p><h2 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h2><p>那么，如果我们要来实现Vue的功能，代码我们该怎么写呢？这里有一个小小的例子供你参考</p><p>html页面：</p><pre><code>&lt;div id="app"&gt;    Hello World!&lt;/div&gt;</code></pre><p>主体部分</p><pre><code>//模仿Vue操作dom的语法//我们自己创建一个Vue函数const Vue = function({el, data={message:''}}){    //绑定 get和set方法    Object.defineProperty(this,'message',{        get: () =&gt; {            return document.getElementById(el).innerHTML        },        set: val =&gt; {            document.getElementById(el).innerHTML = val        }    })}const v = new Vue({    el: 'app',    data: {        message: 'Wooooooooooo!'    }})v.message                    //返回 Wooooooooooo! 字符串v.message = 'ohhhhhhhhhhh!'    //将div内的内容变为 ohhhhhhhhhhh!</code></pre><p>这样，就能进行数据交互了。</p><p>可以看到，所谓各种库和框架，它们并没有在底层层面上创造新的东西，而只是把原有的概念进行了封装与重组。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（3）：线性代数基础</title>
      <link href="2020/10/24/qc-3/"/>
      <url>2020/10/24/qc-3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>传统计算机使用比特 0 和 1 以及它们之间的逻辑操作 and，or，not，xor 等位运算构造加减乘除，并搭建整个经典计算机体系。</p><p>在量子计算机上，基本的存储单元是量子位，即 Qubit。只要搞明白了 Qubit，以及它们之间的逻辑操作，原理上就可以搭建量子计算机。</p><p>Qubit 可以是任意两个本征态<code>|0&gt;</code>和<code>|1&gt;</code>，或者是它们的线性叠加</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>其中<code>α、β</code>是复数</p><p>可以用向量形式来表示狄拉克符号：</p><script type="math/tex; mode=display">\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix},\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}</script><p>在物理意义上，这对应着薛定谔的猫的状态：0——死，1——生。此时这只猫属于既死又活状态，且概率由<code>α、β</code>决定。</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>这里列举的都是最常用的概念，其他的遇到时再查阅资料即可</p><h3 id="1-线性独立"><a href="#1-线性独立" class="headerlink" title="1. 线性独立"></a>1. 线性独立</h3><p>对于一个矢量集$\mathinner{|\alpha_1\rangle},…,\mathinner{|\alpha_n\rangle}\in V$，如果对于复数$c_i$，当且仅当$c_1=…=c_m=0$时，关系式</p><script type="math/tex; mode=display">c_1\mathinner{|\alpha_1\rangle}+...+c_n\mathinner{|\alpha_n\rangle}=0</script><p>才成立，我们称这些矢量线性独立。</p><h3 id="2-内积"><a href="#2-内积" class="headerlink" title="2. 内积"></a>2. 内积</h3><p>$\mathinner{|\alpha\rangle}、\mathinner{|\beta\rangle}$的内积满足以下性质：</p><ul><li>反称：$\mathinner{\langle\alpha|\beta\rangle}=\mathinner{\langle\beta|\alpha\rangle}^*$</li><li>线性：$\mathinner{\langle\alpha|c\beta+d\gamma\rangle}=c\mathinner{\langle\alpha|\beta\rangle}+d\mathinner{\langle\alpha|\gamma\rangle}$</li><li>正定：$\mathinner{\langle\alpha|\beta\rangle}\ge 0$<br>作为例子，我们定义两个矢量$\mathinner{|\alpha\rangle}=(\alpha_1,…,\alpha_n)$和$\mathinner{|\beta\rangle}=(\beta,…,\beta)$在$C^n$中的内积为<script type="math/tex; mode=display">\mathinner{\langle\alpha|\beta\rangle}=\sum_{i=1}^n\alpha_i^*\beta_i</script></li></ul><h3 id="3-模"><a href="#3-模" class="headerlink" title="3. 模"></a>3. 模</h3><script type="math/tex; mode=display">||\mathinner{|\alpha\rangle}||=\mathinner{\langle\alpha|\alpha\rangle}=\sum_{i=1}^n\alpha_i^*\alpha_i</script><p>量子力学把一个物理系统的态和希尔伯特空间中的单位矢量联系起来，在物理现象和数学之间建立了一座桥梁，这个桥梁便是线性代数。</p><h3 id="4-线性算符"><a href="#4-线性算符" class="headerlink" title="4. 线性算符"></a>4. 线性算符</h3><p>一个算符A将矢量$\mathinner{|\alpha\rangle}\in V$映射到另一个矢量$\mathinner{|\beta\rangle}\in V$，即</p><script type="math/tex; mode=display">\mathinner{|\beta\rangle}=A\mathinner{|\alpha\rangle}</script><p>注意到，对量子比特的操作都是通过线性算符实现的。</p><p>在物理意义上，线性算符就是特定波长频率的射线，用来影响量子比特的行为。</p><p>如果对于$\forall \mathinner{|\alpha\rangle}\in V,A\mathinner{|\alpha\rangle}=B\mathinner{|\alpha\rangle}$，则A和B算符是相等的，记为A=B。</p><p>两个线性算符A和B之和C=A+B也是线性的，为</p><script type="math/tex; mode=display">C\mathinner{|\alpha\rangle}=(A+B)\mathinner{|\alpha\rangle}=A\mathinner{|\alpha\rangle}+B\mathinner{|\alpha\rangle}</script><h3 id="5-泡利矩阵"><a href="#5-泡利矩阵" class="headerlink" title="5. 泡利矩阵"></a>5. 泡利矩阵</h3><p>泡利矩阵是经常用到的一种矩阵，</p><script type="math/tex; mode=display">\sigma_x=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix}，\sigma_y=\begin{pmatrix}0 & -i\\ i & 0\\\end{pmatrix}，\sigma_z=\begin{pmatrix}1 & 0\\ 0 & -1\\\end{pmatrix}</script><p>且它有良好的性质：<br>1) $\sigma_x^2=\sigma_y^2=\sigma_z^2=I$ 其中I是单位阵<br>2) $\sigma_x\sigma_y=i\sigma_z，\sigma_y\sigma_z=i\sigma_x，\sigma_z\sigma_x=i\sigma_y$</p><h3 id="6-投影算符"><a href="#6-投影算符" class="headerlink" title="6. 投影算符"></a>6. 投影算符</h3><p>投影算符是用来测量的一种算符，如果$\mathinner{|\alpha\rangle}\in V$是单位矢量，在$\mathinner{|\alpha\rangle}$的一维投影定义如下：</p><script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}=P_\alpha\mathinner{|\gamma\rangle}=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>该算符叫做投影算符，它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p><h3 id="7-么正算符"><a href="#7-么正算符" class="headerlink" title="7. 么正算符"></a>7. 么正算符</h3><p>若</p><script type="math/tex; mode=display">UU^+=U^+U=I</script><p>则称U是么正的，即酉矩阵，从定义中我们知道，U的伴随算符就是它的逆，即</p><script type="math/tex; mode=display">U^+=U^{-1}</script><p>此外，两个么正算符的乘积UV也是么正的，这是量子门串联的基础</p><script type="math/tex; mode=display">(UV)(UV)^+=UVU^+V^+=I</script><p>么正算符的性质非常重要，因为么正算符不改变一个矢量的模，因此么正算符对希尔伯特空间中的矢量的作用，相当于欧几里得空间的坐标旋转。</p><p>所以量子门都是么正算符。</p><h3 id="8-张量积"><a href="#8-张量积" class="headerlink" title="8. 张量积"></a>8. 张量积</h3><p>在希尔伯特空间$\mathcal{H}=\mathcal{H}_1\otimes\mathcal{H}_2$中，对于矢量$\mathinner{|\alpha\rangle}\in\mathcal{H}_1$，$\mathinner{|\beta\rangle}\in\mathcal{H}_2$，都有一个矢量与它们相联系，且后者称为前两者的张量积，记为$\mathinner{|\alpha\rangle}\otimes\mathinner{|\beta\rangle}$</p><p>经常用简写$\mathinner{|\alpha\rangle}\mathinner{|\beta\rangle}，\mathinner{|\alpha\beta\rangle}，\mathinner{|\alpha,\beta\rangle}$来表示张量积</p><h2 id="0x02-单比特系统"><a href="#0x02-单比特系统" class="headerlink" title="0x02 单比特系统"></a>0x02 单比特系统</h2><p>一个量子位可以表示为一个布洛赫球上的向量，对量子位的操作就是旋转这个向量<br><img src="/img/qc-3-1.png" alt=""><br>而旋转操作是用量子门来实现的，要注意的一点是为了满足归一性，量子门必须是酉矩阵</p><p>有一些常用的单量子门，如<code>NOT</code>门</p><script type="math/tex; mode=display">NOT=\begin{pmatrix}0 & 1\\ 1 & 0\\\end{pmatrix},NOT\mathinner{|0\rangle}=\mathinner{|1\rangle},NOT\mathinner{|1\rangle}=\mathinner{|0\rangle}</script><p><code>NOT</code>门的作用是将量子比特翻转，对应在布洛赫球上的几何意义是将向量翻转</p><h2 id="0x03-多比特系统"><a href="#0x03-多比特系统" class="headerlink" title="0x03 多比特系统"></a>0x03 多比特系统</h2><p>多量子比特之间的关系是用张量积来描述的，比如两量子比特系统有4种基本状态，</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}1\\ 0\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}1\\ 0\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 1\\0\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}1\\ 0\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\1\\0\\\end{pmatrix}</script><script type="math/tex; mode=display">\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=\begin{pmatrix}0\\ 1\\\end{pmatrix}\otimes\begin{pmatrix}0\\ 1\\\end{pmatrix}=\begin{pmatrix}0\\ 0\\0\\1\\\end{pmatrix}</script><p>对于一般的两量子系统，可写作</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\alpha_{00}\mathinner{|00\rangle}+\alpha_{01}\mathinner{|01\rangle}+\alpha_{10}\mathinner{|10\rangle}+\alpha_{11}\mathinner{|11\rangle}</script><p>而双量子门则为4*4的矩阵，例如CNOT门</p><script type="math/tex; mode=display">CNOT=\begin{pmatrix}1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\0 & 0 & 0 & 1\\0 & 0 & 1 & 0\\\end{pmatrix}</script><p>它的作用是，当控制位为1时，翻转目标位，否则不变。</p><p>代入矩阵运算很容易验证，</p><script type="math/tex; mode=display">CNOT\mathinner{|00\rangle}=\mathinner{|00\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|01\rangle}=\mathinner{|01\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|10\rangle}=\mathinner{|11\rangle}</script><script type="math/tex; mode=display">CNOT\mathinner{|11\rangle}=\mathinner{|10\rangle}</script><h2 id="0x04-量子纠缠"><a href="#0x04-量子纠缠" class="headerlink" title="0x04 量子纠缠"></a>0x04 量子纠缠</h2><p>一言以蔽之，在线性代数的视角下，量子纠缠就是无法将态分解成张量积的形式。若</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=H_1 \otimes H_2, \exists \mathinner{|\alpha\rangle}\in H_1, \exists \mathinner{|\beta\rangle}\in H_2 s.t. \mathinner{|\varphi\rangle}=\mathinner{|\alpha\rangle}\otimes \mathinner{|\beta\rangle}</script><p>则该量子态不纠缠。举个例子，有两个双量子系统，分别为$\varphi_1$、$\varphi_2$</p><script type="math/tex; mode=display">\mathinner{|\varphi_1\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|11\rangle})</script><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}(\mathinner{|00\rangle}+\mathinner{|01\rangle})</script><p>其中$\varphi_1$处于纠缠态，而$\varphi_2$不处于纠缠态，原因在于</p><script type="math/tex; mode=display">\mathinner{|\varphi_2\rangle}=\frac{1}{\sqrt{2}}\mathinner{|0\rangle}\otimes (\mathinner{|0\rangle}+\mathinner{|1\rangle})</script><p>$\varphi_2$可以被分解成张量积的形式</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（2）：量子力学基础</title>
      <link href="2020/10/23/qc-2/"/>
      <url>2020/10/23/qc-2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-量子力学公理"><a href="#0x01-量子力学公理" class="headerlink" title="0x01 量子力学公理"></a>0x01 量子力学公理</h2><ol><li>每个物理系统都与希尔伯特空间有关。希尔伯特空间是一个向量空间加上一个内积<code>&lt;a|b&gt;</code>，其满足: </li></ol><ul><li>复共轭关系: <code>&lt;a|b&gt; = &lt;b|a&gt;*</code></li><li>线性关系：<code>&lt;x*a1 + y*a2|b&gt; = x&lt;a1|b&gt; + y&lt;a2|b&gt;</code></li><li>正定性：<code>&lt;a|a&gt; ≥ 0</code></li></ul><ol><li>希尔伯特空间中的每一个<code>raw</code>都与系统的一个状态有关。我们有时称这些<code>raw</code>为<code>kets</code>，并给它们贴上标签，如 <code>|φ&gt;</code>。其对偶向量由<code>bras</code>表示，并标记为<code>&lt;φ|</code>。在矩阵表示中，<code>kets</code>是列向量，而<code>bras</code>是<code>kets</code>的共轭转置，是行向量</li><li>每个测量都对应于埃尔米特算子<code>A = A† = AT*</code></li><li>测量的结果可能是<code>A</code>的特征值</li><li>观测到某一特定值的概率为<script type="math/tex; mode=display">Prob(a=a_n) = \frac{<\varphi|P_{a_n}|\varphi>}{<\varphi|\varphi>}</script></li></ol><p>在这里，<code>Pan</code>是对应于给定测量值的状态集(这也被称为A的特征空间)上的投影。这个表达式中的分母是处理状态向量时没有正确归一化的情况</p><h2 id="0x02-测量"><a href="#0x02-测量" class="headerlink" title="0x02 测量"></a>0x02 测量</h2><p>假设我们有一个三维希尔伯特空间由正交基向量组成，<code>|0&gt;,|1&gt;,|2&gt;</code>，因为它们正交，其内积是<code>&lt;0|1&gt;=&lt;0|2&gt;=&lt;1|2&gt;=0，&lt;0|0&gt;=&lt;1|1&gt;=&lt;2|2&gt;=1</code>，取一个希尔伯特空间的特殊状态：</p><script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=\begin{pmatrix}{}\frac{1}{\sqrt{3}}\\\frac{1}{\sqrt{3}}\\\frac{i}{\sqrt{3}}\\\end{pmatrix}</script><p>这种状态是量子叠加的一个例子，其中系统的状态是基状态的和。我们已经使用了<code>bra-ket</code>符号来表示状态，同时也使用了列向量表示状态，其中列向量中的元素对应于bra-ket符号中基向量前面的系数。基向量前面的系数称为振幅，在任何给定的基状态下找到系统的概率由这个基向量振幅的模的平方得到。在上式中，振幅都是1/3  </p><p>注意，使用上面的公理也可以确定这些概率。例如，求找到系统在<code>|0&gt;</code>状态的概率是多少?  </p><p>根据公理5，概率是以投影的形式给出的(我们将忽略分母，因为在标准化的状态下:<code>&lt;φ|φ&gt;=1</code>)，而投影到<code>|0&gt;</code>状态的是算子为：</p><script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=\left(\begin{array}{c}1\\0\\0\\\end{array}\right)\left(\begin{array}{c}1 & 0 & 0\\\end{array}\right)</script><p>同时，</p><script type="math/tex; mode=display">\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=\begin{pmatrix}\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\\end{pmatrix}</script><p>因此我们可以计算出内积</p><script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p><h2 id="0x03-组合量子系统"><a href="#0x03-组合量子系统" class="headerlink" title="0x03 组合量子系统"></a>0x03 组合量子系统</h2><p>很显然不可能只研究一个量子比特的系统，为了进行计算，往往需要研究多量子系统的希尔伯特空间。</p><p>组合的量子系统可以使用kronecker积来表示。</p><p>考虑两个1量子位的希尔伯特空间的集合，那么他们组合的情况一共有4种，分别是<code>{|00&gt;,|01&gt;,|10&gt;,|11&gt;}</code>，每增加一个量子位，可表示的维度便翻一倍。这种组合称为kronecker积（或者张量积）：</p><script type="math/tex; mode=display">\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=\left(\begin{array}{c}1\\0\\\end{array}\right)\otimes\left(\begin{array}{c}1\\0\\\end{array}\right)=\left(\begin{array}{c}1\\0\\0\\0\\\end{array}\right)</script><p>可见，模拟经典力学是一个难易程度只像粒子数目的多项式一样增加的问题，而模拟量子力学是一个难易程度随粒子数目呈指数级增加的问题</p>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理|量子计算（1）：体系结构</title>
      <link href="2020/10/21/qc-1/"/>
      <url>2020/10/21/qc-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>　　作为一个工程师，我习惯于对任何看起来神秘的事物刨根问底，量子计算同样如此。看到一辆玩具小车在横冲直撞，我会思考这是因为电池驱动的马达带动轴承做旋转运动；看到日升日落，我会思考这是由于万有引力的束缚，抑或是广义相对论的时空约束。<br>　　万物均有体系结构，就算是看起来最反常识的量子力学，也接受薛定谔方程的描述。因此，我把<code>体系结构</code>作为本系列的第一篇文章，作为对自己知识的梳理。<br>　　或许是我担任”计算机组成与体系结构”这门课程助教的原因:)，体系结构这个话题可以聊的就太多了。然而我毕竟不是搞的芯片，因此本文从工程的角度出发，对比经典与量子两种架构，对其进行一个全面的阐述。  </p><h2 id="0x01-经典架构"><a href="#0x01-经典架构" class="headerlink" title="0x01 经典架构"></a>0x01 经典架构</h2><p>　　首先讨论经典计算机的架构，先从最基本的单元说起。<br>　　经典计算机基本单元是比特0-1，用高电平和低电平来表示。比特的基本处理单元是逻辑门，而逻辑门使用晶体管实现。同时使用晶体管可以来构建存储单元SRAM、DRAM，前者是register、cache的主要成分，后者则是memory的主要成分。同样的，像是CPU中的处理单元加法器、算术逻辑单元等等，这些都可以通过晶体管构成。存储单元和处理单元是可以分开的，所以我们有非常出名的冯诺依曼体系结构，它告诉人们一台计算机可以用什么样的方式搭建出来。  </p><p><img src="/img/qc-1-1.png" alt="Fig. 1: MIPS microarchitecture"></p><p>　　上图是一个极度简化的CPU的组成，它包含几个部分，总的概括便是存储器和算术逻辑单元，为了让存储和运算单元组合到一起工作，于是有一个控制器。这些所有单元都是由晶体管构成，所以我们说，数据的存储、处理、控制都是同质的（homogeneous），因此我们可以把它集成到同一块芯片上来。<br>　　有了这样一个架构，我们就可以在上面运行软件了。比如有一个AI应用，它是用编程语言python来实现的，经过编译器进行编译，生成了二进制文件。这些二进制的指令，便放在处理器上面执行。于是经典计算机自顶向下的流程便结束了。  </p><p><img src="/img/qc-1-2.png" alt="">  </p><h2 id="0x02-量子架构"><a href="#0x02-量子架构" class="headerlink" title="0x02 量子架构"></a>0x02 量子架构</h2><p>　　有了经典架构做铺垫，再看量子环境会有什么不同。首先从最基本的单元说起。量子计算机最基本的单元是量子比特（qubit），而量子比特  </p><script type="math/tex; mode=display">\mathinner{|\phi\rangle} = \alpha\mathinner{|0\rangle} + \beta\mathinner{|1\rangle} s.t. |\alpha|^2 + |\beta|^2 = 1</script><p>表示该比特有|α|^2的概率为0，否则为1。该量子比特处于0和1的叠加态之中。同理，若有n个qubit则系统同时有2^n个状态的叠加。<br>　　量子计算和经典计算不同的一点在于，量子比特既是数据存储的单元，又是数据处理的单元，因此运算过程就发生在量子比特身上。经典计算机使用逻辑门处理比特，而量子计算机使用量子门来处理。量子门处理的过程是对所有比特进行处理，同时有着巨大的状态空间以及巨大的并行性，因此量子算法效率往往会有指数级别的提升。在简单的介绍之后，下面从工程的角度来看一些实物，一个量子芯片到底该长啥样。  </p><p><img src="/img/qc-1-3.png" alt="">  </p><p>　　上图量子芯片来自荷兰代尔夫特理工大学实验室，它在20mK温度下工作，只有两个量子比特[28]（芯片中央两个黑色圆点）。现探索该量子比特的结构。<br>图1.11(a)则为上图量子芯片中的量子比特放大图，可以看到上极板有3个接口，下极板也有3个接口连接出去，两个极板中间有一层介质，它们共同构成了电容。图1.11(b)是该结构的电路图，图中线条标注了它们之间的对应关系。  </p><p><img src="/img/qc-1-4.png" alt="">    </p><p>　　图中黑色线条相连的部分是电容，红色线条相连的部分是约瑟夫森结（Josephson junction）。这两个约瑟夫森结等效于一个电感，于是这个电路中有了电容、电感，就构成了一个LC振荡电路。那么能量就在电容与电感之间来回震荡。如果用量子电动力学去探索它的基态，可以看到它是一个等分的能级的结构，于是我们可以得到这样一个能量间隔不均匀的能级图：  </p><p><img src="/img/qc-1-5.png" alt="">    </p><p>　　取最低能级为0，取第一激发态为1来作为量子态，这样就构成了一个量子比特。注意在这里，我们观测的是整个约瑟夫森结的状态，也就是说观测的量子状态是宏观的，这就相当于用宏观的表现来观测到了微观的量子状态，所以我们才能操作量子比特。<br>　　有了量子比特后，该怎么对量子比特进行操纵呢，这是通过良好定义的波形来实现的。在图1.10中，可以看到该量子芯片周围有6个接口，这些接口通过导线连接到外部，因此能够通过这些接口把波形传到量子比特上面去。比如说单比特门就用20ns的脉冲，通过接口打在量子比特上面去。<br>　　现在回到上面说的问题，在经典计算机中，存储单元和处理单元是分离的。而在量子计算机中，量子比特既是数据存储的地方，又是数据处理的地方，控制媒介则是模拟波形（模拟信号）。经典电路控制媒介则是数字信号。在经典的架构中，有了CPU便可以直接安装软件运行，而在量子计算机中，由于它们是异构的（同时存在模拟/数字信号），则需要一个专门的控制器来进行沟通转换。就是说在软件和量子比特之间一定要引入一个控制器。  </p><p><img src="/img/qc-1-6.png" alt="">    </p><p>　　上图中，AWG（Arbitrary waveform generator）是任意波形发生器的缩写，用它来发射定义好的模拟波形来操作量子比特。Data Collection Card（数据采集卡）用来采集测量量子比特后返回的结果，这个测量结果也是模拟信号，所以要对模拟信号进行识别从而判断结果是0还是1。整个流程便是PC机软件控制发出数字波形，然后控制器中的AWGs发出定义好的模拟波形打在量子比特上，最后测量结果返回给数字采集卡，数字采集卡判断结果后返回给PC主机。这是过去主流的控制量子比特的方法，也是目前少数实验室采用的方法，但是它是不可扩展的，因此后面会提到全栈量子计算机的架构。<br>　　现在可以比较经典计算和量子计算的不同了：  </p><ol><li>从数据流过程上。经典计算是把数据流拿出来运动，经过一个个函数/运算模块中处理，最后得到结果。所以是数据在动，操作不动。而量子计算中，所有数据保存在量子比特上面，我们把操作一个个的打上去，所以是数据不动，操作在动。这种不同也决定了量子计算机的体系结构和经典是不同的。  </li><li>从编程语言上。经典计算发展到现在，有无数编程语言能够满足经典计算的使用。为了描述与操作量子比特，现在也有很多量子高级语言（如Qiskit），然而这些语言经典算法中的高级特性，如递归等操作并没有很好的实现。在使用量子高级语言的时候，更多的是考虑如何实现电路图，这对于量子算法的产生是个很不利的因素。  </li></ol><p>　　在图1.13控制方法中，控制流程是不可扩展的，因此现在主流的组成如下图所示  </p><p><img src="/img/qc-1-7.png" alt="">  </p><p>　　最上层是一些量子算法，如shor算法等等；中间一层是编程语言和编译器，如Qiskit、Q#、QPanda等等；再下面是要转化成的指令集，如eQASM、OpenQASM；最下层便是量子芯片，可能是超导芯片、离子阱等等。<br>　　接下来看看IBM对它的物理实现：  </p><p><img src="/img/qc-1-8.png" alt="">  </p><p>　　上图(a)就是IBM展示的量子计算机，(b)是封装起来的样子，其内部是一个大号的“冰箱”，芯片要求在20mK的温度下工作。    </p><h2 id="0x03-现在-amp-未来"><a href="#0x03-现在-amp-未来" class="headerlink" title="0x03 现在&amp;未来"></a>0x03 现在&amp;未来</h2><p>　　上面说了那么多过去的知识，接下来看看现在此刻的芯片所处的时代~<br>　　学术界预计在未来几年内，我们将进入有噪声中间量子(Noisy Intermediate-Scale Quantum,NISQ)时代，届时具有数十到数百个量子位元的QC器件将面世。<br>　　虽然量子位的数量不足以构成量子纠错(QEC)，但它仍然被期望使用超出可用的经典计算机的能力，来解决现实世界的问题。<br>　　在NISQ时代，由于技术的限制，量子软件和硬件之间存在差距。当前最流行的电路模型设计一个量子程序时，总是假设量子位和量子操作是完美的，你可以应用任何量子物理操作。但在NISQ硬件上，量子位的相干时间有限，量子运算也不完美。下图是 IBM Q20 芯片，可以看到其参数如图  </p><p><img src="/img/qc-1-9.png" alt="Fig. 2:  IBM Q20 Tokyo Information">  </p><p>　　上图显示了有关IBMQ 20芯片的信息，量子比特的平均寿命仅仅约为50µs，同时量子门之间的操作也有错误率，这意味着该芯片将无法运行大规模的程序。量子比特被放置在一个平面几何体上，由于芯片上的放置和路由限制，耦合器只能将一个量子比特连接到相邻的量子比特上。<br>　　有学者估计，要使量子计算机达到通用计算机的程度，至少需要数十万个量子比特，而当前的进展仅仅是几十个比特。或许将量子计算机作为专用计算才是未来的方向，毕竟从理论到实践的路还很漫长…<br>　　事实上，如今的量子计算机是作为云的形式提供服务的，因为目前最流行的超导体系结构无法在室温下工作，所以只能通过提供API的方式调用。这是不是很像云计算？这也是实验室之外唯一能够使用量子芯片的方法了，目前国外有IBM提供的免费量子芯片可供使用（虽然才5比特…），并且需要排队才能申请到使用权限。    </p><p>　　PS：前两天习大大提出要发展量子科技，难道这个冷门中的冷门方向要出头了吗？！惊了！</p><blockquote><p>Reference<br>[1] John Preskill. Quantum computing in the nisq era and beyond. arXiv preprint arXiv:1801.00862, 2018.<br>[2] Sergio Boixo, Sergei V Isakov, Vadim N Smelyanskiy, Ryan Babbush, Nan Ding, Zhang Jiang, Michael J Bremner, John M Martinis, and Hartmut Neven. Characterizing quantum supremacy in near-term devices. Nature Physics, 14(6):595, 2018.<br>[3] IBM. IBM Q Experience Device. <a href="https://quantumexperience.ng.bluemix">https://quantumexperience.ng.bluemix</a>. net/qx/devices, 2018.<br>[4] Li G, Ding Y, Xie Y. Tackling the qubit mapping problem for NISQ-era quantum devices[C]//Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems. 2019: 1001-1014.  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子计算 </tag>
            
            <tag> 梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我常用的一些学术资源</title>
      <link href="2020/10/21/xue-zhu-zi-yuan/"/>
      <url>2020/10/21/xue-zhu-zi-yuan/</url>
      
        <content type="html"><![CDATA[<p>不定期更新~<span class="github-emoji"><span>😗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f617.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="0x01-论文相关"><a href="#0x01-论文相关" class="headerlink" title="0x01 论文相关"></a>0x01 论文相关</h2><ul><li>sci-hub可用链接<ul><li><a href="https://sci-hub.shop/">备用1</a></li><li><a href="https://sci-hub.ren/">备用2</a></li><li><a href="https://gfsoso.99lb.net/sci-hub.html">一个综合工具，都不行就用这个</a></li></ul></li><li><a href="http://www.letpub.com.cn/index.php?page=journalapp">中科院分区</a><ul><li>查询论文的级别很好用</li></ul></li></ul><h2 id="0x02-软件"><a href="#0x02-软件" class="headerlink" title="0x02 软件"></a>0x02 软件</h2><ul><li>常用软件的安装<ul><li><a href="http://lookdiv.com/">webstrom激活</a></li><li><a href="https://blog.csdn.net/Slatter/article/details/88730542?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">matlab 2018a</a></li></ul></li></ul><h2 id="0x03-实用网站"><a href="#0x03-实用网站" class="headerlink" title="0x03 实用网站"></a>0x03 实用网站</h2><ul><li><a href="https://www.wolframalpha.com/">wolframalpha</a><ul><li>非常好用的数学计算工具，nice！<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>可识别自然语言，功能非常齐全</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
