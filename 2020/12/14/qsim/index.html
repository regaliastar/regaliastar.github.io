

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="mumu">
  <meta name="keywords" content="">
  <title>实现一个量子计算机 - Mumu</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hahuillu.cn","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Mumu" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Mumu</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="实现一个量子计算机">
              
                实现一个量子计算机
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-14 11:07" pubdate>
        December 14, 2020 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      41
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">实现一个量子计算机</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：December 25, 2020 am
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近量子计算很火的样子，作为一个学计算机的，我们不妨自己做一个量子计算机<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" srcset="/img/loading.gif" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>所谓的量子计算机，就是控制一系列量子比特的演化过程，对其施以酉变换，通过测量得出结果的装置。</p>
<p>在量子计算中，线路模型和图灵机模型理论上是等价的，最常用的量子计算模型便是线路模型，除此之外还有基于测量的模型，而前者比后者更直观简单，这也是我们选择用线路模型来实现的原因了。</p>
<p>下面我们用经典计算机来模拟量子计算的过程，实现一个量子计算模拟器（玩具版）。</p>
<h2 id="量子比特"><a href="#量子比特" class="headerlink" title="量子比特"></a>量子比特</h2><p>经典计算机使用比特进行计算，量子计算机就有量子比特，而单量子比特的矩阵表示有：</p>
<script type="math/tex; mode=display">\mathinner{|0\rangle}=
\begin{pmatrix}
1\\ 
0\\
\end{pmatrix}
,
\mathinner{|1\rangle}=
\begin{pmatrix}
0\\ 
1\\
\end{pmatrix}</script><p>对于多量子比特，则是单量子比特之间进行kronecker积：</p>
<script type="math/tex; mode=display">
\mathinner{|00\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|0\rangle}=
\begin{pmatrix}
1\\ 
0\\
\end{pmatrix}
\otimes
\begin{pmatrix}
1\\ 
0\\
\end{pmatrix}
=
\begin{pmatrix}
1\\ 
0\\
0\\
0\\
\end{pmatrix}</script><script type="math/tex; mode=display">
\mathinner{|01\rangle}=\mathinner{|0\rangle}\otimes\mathinner{|1\rangle}=
\begin{pmatrix}
1\\ 
0\\
\end{pmatrix}
\otimes
\begin{pmatrix}
0\\ 
1\\
\end{pmatrix}
=
\begin{pmatrix}
0\\ 
1\\
0\\
0\\
\end{pmatrix}</script><script type="math/tex; mode=display">
\mathinner{|10\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|0\rangle}=
\begin{pmatrix}
0\\ 
1\\
\end{pmatrix}
\otimes
\begin{pmatrix}
1\\ 
0\\
\end{pmatrix}
=
\begin{pmatrix}
0\\ 
0\\
1\\
0\\
\end{pmatrix}</script><script type="math/tex; mode=display">
\mathinner{|11\rangle}=\mathinner{|1\rangle}\otimes\mathinner{|1\rangle}=
\begin{pmatrix}
0\\ 
1\\
\end{pmatrix}
\otimes
\begin{pmatrix}
0\\ 
1\\
\end{pmatrix}
=
\begin{pmatrix}
0\\ 
0\\
0\\
1\\
\end{pmatrix}</script><p>可以看到，对于2个比特的系统，向量的维度是4，而对于n个比特的系统，向量的维度就是$2^n$。可以做一个简单的估计，假设我们使用复数存储一个数字，计算它占据的大小<code>sys.getsizeof(c)</code>为32个字节，也就是说对于10比特的量子计算机，存储状态的空间就有32KB，对于20比特需要32MB，而30个量子比特就需要32GB，再往下就超出了个人计算机的极限了。</p>
<p>由于维度是指数级的增加，因此在经典计算机上只能进行有限的模拟，2018年一篇顶刊使用超级计算机（天河二号）模拟了超过50个量子比特，这已经是很大的进步了。当然，我们这里只是个玩具量子计算机 :)</p>
<p>首先引入需要的包：<br></p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-title">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> normalize<br></code></pre></td></tr></tbody></table></figure><br>现在生成初态的量子比特，1位比特维度是2，n位比特维度是$2^n$，使用kronecker积对比特维度进行计算。<p></p>
<p>定义 <code>basis</code> 方法得到kronecker积：<br></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">def basis(<span class="hljs-built_in">string</span>=<span class="hljs-string">'00000'</span>):<br>    spin_up = np.array(<span class="hljs-string">[[1, 0]]</span>).T<br>    spin_down = np.array(<span class="hljs-string">[[0, 1]]</span>).T<br>    bit = [spin_up, spin_down]<br>    res = np.array(<span class="hljs-string">[[1]]</span>)<br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">string</span>[::<span class="hljs-number">-1</span>]:<br>        res = np.kron(bit[int(idx)], res)<br>    <span class="hljs-keyword">return</span> np.matrix(res)<br></code></pre></td></tr></tbody></table></figure><br>打开 <code>jupyter</code> 测试一下，生成4个量子比特 <code>0100</code> 的初态：<br><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">amplitudes</span> = basis(<span class="hljs-string">'0100'</span>).A1<br></code></pre></td></tr></tbody></table></figure><br>打印 <code>amplitudes</code>:  <p></p>
<p><code>[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</code> </p>
<p><strong>如果想生成任意振幅的量子比特呢？</strong></p>
<p>在一个量子系统中，波函数可以写作：</p>
<script type="math/tex; mode=display">
\mathinner{|\varphi\rangle} = \sum_{i=0}^{2^n-1}\alpha_i\mathinner{|i\rangle} \quad s.t. \sum_{i=0}^{2^n-1}\alpha_i^2 = 1</script><p>其中$\alpha_i$是振幅，$\mathinner{|i\rangle}$是基底，它们乘积之和就得到了一个叠加的波函数。</p>
<p>于是可以定义波函数 <code>wave_func</code><br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wave_func</span>(<span class="hljs-params">coef=[], seqs=[]</span>):</span><br>    <span class="hljs-string">'''返回由振幅和几个Qubit序列表示的叠加态波函数'''</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(coef):<br>        res += a * basis(seqs[i])<br>    <span class="hljs-keyword">return</span> np.matrix(res)<br></code></pre></td></tr></tbody></table></figure><br>测试一下，生成量子叠加态 $\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}(\mathinner{|00\rangle}+\mathinner{|01\rangle}+\mathinner{|11\rangle})$:<br><figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lsl">coef = [np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>), np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>), np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)]<br>amplitudes = wave_func(coef=coef, seqs=['<span class="hljs-number">00</span>','<span class="hljs-number">01</span>','<span class="hljs-number">11</span>']).A1<br></code></pre></td></tr></tbody></table></figure><br>打印 <code>amplitudes</code>: <p></p>
<p><code>[0.57735027 0.57735027 0.         0.57735027]</code> </p>
<p>注意到，这种表示方法非常的不友好，简直不是人读的！于是我们尝试对波函数在投影方向进行分解。</p>
<p>这里我们有投影算符：</p>
<script type="math/tex; mode=display">\forall\mathinner{|\gamma\rangle}\in V，\mathinner{|\beta\rangle}
=P_\alpha\mathinner{|\gamma\rangle}
=\mathinner{|\alpha\rangle}\mathinner{\langle\alpha|\gamma\rangle}
=\mathinner{\langle\alpha|\gamma\rangle}\mathinner{|\alpha\rangle}</script><p>它把一个一般的矢量$\mathinner{|\gamma\rangle}$投影到$\mathinner{|\alpha\rangle}$的方向上。</p>
<p>先进行前置的准备工作：Hilbert空间是一个内积空间，所有量子比特都在Hilbert空间内。</p>
<p>定义生成 <code>Hilbert空间</code> 函数：</p>
<figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def hilbert_space(nbit=<span class="hljs-number">5</span>):<br>    nspace = <span class="hljs-number">2</span> ** nbit<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nspace):<br>        # bin(<span class="hljs-number">7</span>) = <span class="hljs-number">0b100</span><br>        binary = bin(i)[<span class="hljs-number">2</span>:]<br>        nzeros = nbit - len(binary)<br>        yield '<span class="hljs-number">0</span>' * nzeros + binary<br></code></pre></td></tr></tbody></table></figure>
<p>再沿投影方向分解，投影的方向就是基向量的方向：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">project</span>(<span class="hljs-params">wave_func, direction</span>):</span><br>    <span class="hljs-string">'''&lt;Psi | phi_i&gt; to get the amplitude'''</span><br>    <span class="hljs-keyword">return</span> wave_func.H * direction<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decompose</span>(<span class="hljs-params">wave_func</span>):</span><br>    <span class="hljs-string">'''将叠加态波函数分解'''</span><br>    nbit = <span class="hljs-built_in">int</span>(np.log2(<span class="hljs-built_in">len</span>(wave_func)))<br>    amplitudes = []<br>    direct_str = []<br>    <span class="hljs-keyword">for</span> seq <span class="hljs-keyword">in</span> hilbert_space(nbit):<br>        direct = basis(seq)<br>        amp = project(wave_func, direct).A1[<span class="hljs-number">0</span>]  <span class="hljs-comment">#A1 属性将矩阵转化为 1 维 numpy 数组</span><br>        <span class="hljs-keyword">if</span> np.linalg.norm(amp) != <span class="hljs-number">0</span>:<br>            amplitudes.append(amp)<br>            direct_str.append(seq)<br>    <span class="hljs-keyword">return</span> amplitudes, direct_str<br></code></pre></td></tr></tbody></table></figure><br>定义函数<code>a2wf</code>将 振幅 转为能被 <code>print_wf</code> 函数解析的 <code>wave_func</code> 格式<br><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a2wf</span><span class="hljs-params">(amplitudes, n)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-keyword">return</span> np.mat(amplitudes.reshape(<span class="hljs-number">2</span> ** n, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><br>再使用 <code>print_wf</code> 函数打印出波函数<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_wf</span>(<span class="hljs-params">wf</span>):</span><br>    coef, seqs = decompose(wf)<br>    <span class="hljs-built_in">str</span> = <span class="hljs-string">'|psi&gt; = '</span><br>    <span class="hljs-keyword">for</span> i, seq <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seqs):<br>        <span class="hljs-built_in">str</span> += <span class="hljs-string">'{}|{}&gt;'</span>.<span class="hljs-built_in">format</span>(coef[i], seq)<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-built_in">len</span>(seqs) - <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">str</span> += <span class="hljs-string">'+'</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></tbody></table></figure><p></p>
<p>测试一下，生成一个大名鼎鼎的 <code>bell</code> 纠缠态 $\mathinner{|\varphi\rangle} = \frac{1}{\sqrt{2}}\mathinner{|00\rangle} + \frac{1}{\sqrt{2}}\mathinner{|11\rangle}$：<br></p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wf</span> = a<span class="hljs-number">2</span>wf(np.matrix([np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,np.sqrt(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)]), <span class="hljs-number">2</span>)<br><span class="hljs-attribute">print_wf</span>(wf)<br></code></pre></td></tr></tbody></table></figure><p></p>
<p>打印：<br><code>|psi&gt; = 0.7071067811865476|00&gt;+0.7071067811865476|11&gt;</code></p>
<p>现在看起来就直观多了~</p>
<h2 id="量子门"><a href="#量子门" class="headerlink" title="量子门"></a>量子门</h2><p>量子计算机仅仅只有量子比特是不够的，为了实现量子算法，还需要对量子比特进行酉变换，这种变换我们使用量子门实现。</p>
<p>量子比特可以看做是布洛赫球上的一个向量：<br><img src="/img/qc-3-1.png" srcset="/img/loading.gif" alt=""><br>量子门对应的就是该向量的旋转，要注意的一点是为了满足归一性，量子门必须是酉矩阵。</p>
<p>量子门分为单比特量子门和多比特量子门，对于单比特量子门，常用的有泡利矩阵：</p>
<script type="math/tex; mode=display">
\sigma_x=
\begin{pmatrix}
0 & 1\\ 
1 & 0\\
\end{pmatrix}，
\sigma_y=
\begin{pmatrix}
0 & -i\\ 
i & 0\\
\end{pmatrix}，
\sigma_z=
\begin{pmatrix}
1 & 0\\ 
0 & -1\\
\end{pmatrix}</script><p>代码实现：<br></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">X = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br>Y = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>j], [<span class="hljs-number">1</span>j, <span class="hljs-number">0</span>]])<br>Z = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>]])<br></code></pre></td></tr></tbody></table></figure><br>Hadamard门：<br><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">H = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)], [<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>), -<span class="hljs-number">1</span> / <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)]])<br></code></pre></td></tr></tbody></table></figure><br>T门：<br><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">T = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, np.exp(<span class="hljs-number">1</span>j * np.pi / <span class="hljs-number">4</span>)]])<br></code></pre></td></tr></tbody></table></figure><br>V门：<br><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">V = np.<span class="hljs-built_in">array</span>([[(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>j * (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>], [<span class="hljs-number">-1</span>j * (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>, (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>j) / <span class="hljs-number">2</span>]])<br></code></pre></td></tr></tbody></table></figure><br>我们将 <code>X</code> 门施加到一个基态为<code>0</code>的量子比特上：<br><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">amplitudes = basis(<span class="hljs-string">'0'</span>).A1<br>wf = np.dot(amplitudes, X)<br><span class="hljs-function"><span class="hljs-title">print_wf</span><span class="hljs-params">(a2wf(wf, <span class="hljs-number">1</span>)</span></span>)<br></code></pre></td></tr></tbody></table></figure><br>打印：<br><code>|psi&gt; = 1|1&gt;</code>  <p></p>
<p>完全符合预期。</p>
<p><strong>下面构造双量子门。</strong></p>
<p>已经被证明，所有多量子门都可以用双量子门和单量子门生成，因此我们只需要构造双量子门即可。</p>
<p>一般的双量子门有两种情况：</p>
<ol>
<li>控制位在上</li>
<li>控制位在下</li>
</ol>
<p>第一种情况很常见，如：</p>
<script type="math/tex; mode=display">CNOT=
\begin{pmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0\\
\end{pmatrix}</script><p>对于第二种情况，只需要将内部交换顺序，使用<code>CNOT_DOWN</code>表示控制位在下：</p>
<script type="math/tex; mode=display">CNOT\_DOWN=
\begin{pmatrix}
0 & 1 & 0 & 0\\
1 & 0 & 0 & 0\\
0 & 0 & 1 & 0\\ 
0 & 0 & 0 & 1\\
\end{pmatrix}</script><p>同时，控制位和作用位不一定是紧挨着，它们之间可能存在<em>跨线</em>，这种情况稍微复杂一点。</p>
<p>还是拿<code>CNOT</code>门来举例，对于<strong>跨一条线且控制位在上</strong>的控制非门，我们定义为<code>CNOT3_02</code>，它的矩阵形式：</p>
<script type="math/tex; mode=display">CNOT3\_02=
\begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
\end{pmatrix}</script><p>可以看到，矩阵左上角是不变的，右下角重复<code>X</code>门</p>
<p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：<br></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">base = np.identity(m_size)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">4</span>)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>            base[<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">2</span> + i * <span class="hljs-number">2</span> + j)][<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">2</span> + i * <span class="hljs-number">2</span> + k)] = GateManager.Gates[gate][j][k]<br></code></pre></td></tr></tbody></table></figure><p></p>
<p>对于<strong>跨一条线且控制位在下</strong>的控制非门，会更麻烦一点，<br>我们定义为<code>CNOT3_20</code>，它的矩阵形式：</p>
<script type="math/tex; mode=display">CNOT3\_20=
\begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
\end{pmatrix}</script><p>推广到一般的情况，假设<code>m_size</code>表示门的维度，使用代码表示：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">base = np.identity(m_size)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">int</span>(m_size / <span class="hljs-number">4</span>)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>            base[<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * i + j * m_size / <span class="hljs-number">2</span>)][<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * i + k * m_size / <span class="hljs-number">2</span>)] = GateManager.Gates[gate][j][k]<br></code></pre></td></tr></tbody></table></figure>
<h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>一个量子系统是一个黑盒，在测试之前我们永远不知道它会塌缩到什么状态，而一个黑盒对我们来说是没有意义的。因此，从黑盒中提取出有用信息的过程就是测量了。</p>
<p>测量会将量子比特塌缩为经典比特，而该量子比特的振幅就是塌缩成0或1的概率。举个例子，对于一个量子状态</p>
<script type="math/tex; mode=display">\mathinner{|\varphi\rangle}=\frac{1}{\sqrt{3}}\mathinner{|0\rangle}+\frac{1}{\sqrt{3}}\mathinner{|1\rangle}+\frac{i}{\sqrt{3}}\mathinner{|2\rangle}=
\begin{pmatrix}{}
\frac{1}{\sqrt{3}}\\
\frac{1}{\sqrt{3}}\\
\frac{i}{\sqrt{3}}\\
\end{pmatrix}</script><p>概率是以投影的形式给出的，而投影到<code>|0&gt;</code>状态的是算子为：</p>
<script type="math/tex; mode=display">P_0=\mathinner{|0\rangle}\mathinner{\langle 0|}=
\left(
\begin{array}{c}
1\\
0\\
0\\
\end{array}
\right)
\left(
\begin{array}{c}
1 & 0 & 0\\
\end{array}
\right)</script><p>同时，</p>
<script type="math/tex; mode=display">
\mathinner{\langle \varphi|}=\mathinner{|\varphi\rangle}^+=\frac{1}{\sqrt{3}}\mathinner{\langle 0|}+\frac{1}{\sqrt{3}}\mathinner{\langle 1|}+\frac{-i}{\sqrt{3}}\mathinner{\langle 2|}=
\begin{pmatrix}
\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{3}} & \frac{-i}{\sqrt{3}}\\
\end{pmatrix}</script><p>因此我们可以计算出内积</p>
<script type="math/tex; mode=display">Prob(0)=\mathinner{\langle \varphi|}P_0\mathinner{|\varphi\rangle}=
\mathinner{\langle \varphi|0 \rangle}\mathinner{\langle 0|\varphi \rangle}=
|\mathinner{\langle 0|\varphi \rangle}|^2=\frac{1}{3}</script><p>通过测量算子，便求出了状态$\mathinner{|\varphi\rangle}$塌缩到$\mathinner{|0\rangle}$的概率为$\frac{1}{3}$</p>
<p>已知了原理部分，就可以进行编码了。我们的量子计算机有两种测量方式，分别是进行全局测量和对单个比特进行测量，全局测量就是对所有比特同时进行测量：<br></p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def measureAll():<br>    probabilities = []<br>    <span class="hljs-keyword">for</span> amp <span class="hljs-keyword">in</span> <span class="hljs-built_in">np</span>.nditer(amplitudes):<br>        probability = <span class="hljs-built_in">np</span>.absolute(amp)**<span class="hljs-number">2</span><br>        probabilities.<span class="hljs-built_in">append</span>(probability)<br>    results = list(<span class="hljs-built_in">range</span>(len(probabilities)))<br>    value = <span class="hljs-built_in">np</span>.binary_repr(<br>        <span class="hljs-built_in">np</span>.<span class="hljs-built_in">random</span>.choice(results, p=probabilities),<br>        numQubits<br>    )<br>    <span class="hljs-built_in">return</span> value<br></code></pre></td></tr></tbody></table></figure><br>我们也可以对单个比特进行测量：<br><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl">def measureOne(place):<br>    prob_<span class="hljs-number">0</span> = <span class="hljs-number">0</span><br>    probabilities = np.zeros(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i, seq in enumerate(seqs):<br>        prob_<span class="hljs-number">0</span> += np.square(coef[i]) <span class="hljs-keyword">if</span> se<span class="hljs-string">q[index]</span> == <span class="hljs-string">'0'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    probabilities[<span class="hljs-number">0</span>] = prob_<span class="hljs-number">0</span><br>    probabilities[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> - prob_<span class="hljs-number">0</span><br>    ls = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>    selected = np.random.choice(ls, p=probabilities)<br>    measured[place] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 重新生成状态</span><br>    co = []<br>    ba = []<br>    <span class="hljs-keyword">for</span> i, seq in enumerate(seqs):<br>        <span class="hljs-keyword">if</span> se<span class="hljs-string">q[index]</span> == str(selected):<br>            co.append(coef[i])<br>            ba.append(se<span class="hljs-string">q[0:index]</span> + se<span class="hljs-string">q[index+1:len(seq)]</span>)<br>    co = normalization(co)<br>    amplitudes = wave_func(co, ba).A1<br>    numQubits = len(ba[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> selected<br></code></pre></td></tr></tbody></table></figure><br>不同的是，在进行单个比特的测量后，需要重新生成状态。<p></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如此一来，我们就实现了一个量子计算机，麻雀虽小五脏俱全，绝大部分量子算法都可以用这个玩具实现了~</p>
<p>总结一下，我们用到了哪些知识：</p>
<ul>
<li>线性代数</li>
<li>量子力学基础</li>
<li>Python</li>
</ul>
<p>未来可以给这个量子计算机加上其他的功能，比如 <em>量子排列优化</em>、<em>量子线路分解</em>、<em>量子并行模拟</em> 等等，总之接下来就是搭积木了</p>
<blockquote>
<p>Reference<br>[1] <a target="_blank" rel="noopener" href="https://github.com/adamisntdead/QuSimPy">https://github.com/adamisntdead/QuSimPy</a><br>[2] <a target="_blank" rel="noopener" href="https://github.com/corbett/QuantumComputing">https://github.com/corbett/QuantumComputing</a><br>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/267302584">https://zhuanlan.zhihu.com/p/267302584</a><br>[4] <a target="_blank" rel="noopener" href="https://qiskit.org/">qiskit文档</a></p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/">量子计算</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/python/">python</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/">量子计算</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/16/leet-algo/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">总结|常用算法</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/13/phy-history/">
                        <span class="hidden-mobile">从奥术神座到数理学史</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "tczSpze7CzwpuBSXKSKOqWzd-gzGzoHsz",
          app_key: "HNDDKbcPYSvhQmw5HcuBOjQx",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://tczspze7.lc-cn-n1-shared.com",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/regaliastar" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/regaliastar" target="_blank" rel="nofollow noopener"><span>Mumu</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>






  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
